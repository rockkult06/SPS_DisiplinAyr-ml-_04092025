"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/collective-weights/page",{

/***/ "(app-pages-browser)/./lib/neon-db.ts":
/*!************************!*\
  !*** ./lib/neon-db.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAverageWeights: () => (/* binding */ calculateAverageWeights),\n/* harmony export */   checkDatabaseConnection: () => (/* binding */ checkDatabaseConnection),\n/* harmony export */   deleteAHPEvaluation: () => (/* binding */ deleteAHPEvaluation),\n/* harmony export */   deleteAllAHPEvaluations: () => (/* binding */ deleteAllAHPEvaluations),\n/* harmony export */   deleteMultipleAHPEvaluations: () => (/* binding */ deleteMultipleAHPEvaluations),\n/* harmony export */   getAHPEvaluationByUser: () => (/* binding */ getAHPEvaluationByUser),\n/* harmony export */   getAllAHPEvaluations: () => (/* binding */ getAllAHPEvaluations),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   initializeDatabase: () => (/* binding */ initializeDatabase),\n/* harmony export */   isDatabaseReady: () => (/* binding */ isDatabaseReady),\n/* harmony export */   saveAHPEvaluation: () => (/* binding */ saveAHPEvaluation)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var _neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neondatabase/serverless */ \"(app-pages-browser)/./node_modules/@neondatabase/serverless/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE TABLE IF NOT EXISTS ahp_evaluations (\\n        id TEXT PRIMARY KEY,\\n        user_name TEXT NOT NULL,\\n        criteria_weights JSONB NOT NULL,\\n        global_weights JSONB NOT NULL,\\n        consistency_results JSONB NOT NULL,\\n        hierarchy_data JSONB NOT NULL,\\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\\n      )\\n    \"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE INDEX IF NOT EXISTS idx_ahp_evaluations_user_name\\n      ON ahp_evaluations(user_name)\\n    \"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE INDEX IF NOT EXISTS idx_ahp_evaluations_updated_at\\n      ON ahp_evaluations(updated_at)\\n    \"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      SELECT id FROM ahp_evaluations WHERE user_name = \",\n        \"\\n    \"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject4() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n        UPDATE ahp_evaluations SET\\n          criteria_weights   = \",\n        \",\\n          global_weights     = \",\n        \",\\n          consistency_results= \",\n        \",\\n          hierarchy_data     = \",\n        \",\\n          updated_at         = \",\n        \"\\n        WHERE user_name      = \",\n        \"\\n        RETURNING *\\n      \"\n    ]);\n    _templateObject4 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject5() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      INSERT INTO ahp_evaluations (\\n        id, user_name, criteria_weights, global_weights,\\n        consistency_results, hierarchy_data, created_at, updated_at\\n      ) VALUES (\\n        \",\n        \", \",\n        \", \",\n        \", \",\n        \",\\n        \",\n        \", \",\n        \", \",\n        \", \",\n        \"\\n      )\\n      RETURNING *\\n    \"\n    ]);\n    _templateObject5 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject6() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT * FROM ahp_evaluations ORDER BY updated_at DESC\"\n    ]);\n    _templateObject6 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject7() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT * FROM ahp_evaluations WHERE user_name = \",\n        \"\"\n    ]);\n    _templateObject7 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject8() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations WHERE id = \",\n        \" RETURNING id\"\n    ]);\n    _templateObject8 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject9() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations WHERE id = ANY(\",\n        \") RETURNING id\"\n    ]);\n    _templateObject9 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject10() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations RETURNING id\"\n    ]);\n    _templateObject10 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject11() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      SELECT \\n        COUNT(*) as total_evaluations,\\n        MAX(updated_at) as last_updated\\n      FROM ahp_evaluations\\n    \"\n    ]);\n    _templateObject11 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject12() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT 1 as test\"\n    ]);\n    _templateObject12 = function() {\n        return data;\n    };\n    return data;\n}\n\n/* ------------------------------------------------------------------ */ /*  Neon connection (or in-memory fallback)                           */ /* ------------------------------------------------------------------ */ let sql = null;\nlet neonReady = false;\nlet connectionError = null;\n// DATABASE_URL validation\nfunction validateDatabaseUrl(url) {\n    try {\n        // Neon URL should start with postgresql:// or postgres://\n        if (!url.startsWith(\"postgresql://\") && !url.startsWith(\"postgres://\")) {\n            return false;\n        }\n        // Basic URL validation\n        const urlObj = new URL(url);\n        return urlObj.hostname && urlObj.pathname;\n    } catch (e) {\n        return false;\n    }\n}\ntry {\n    if (process.env.DATABASE_URL) {\n        console.log(\"DATABASE_URL found, validating...\");\n        if (!validateDatabaseUrl(process.env.DATABASE_URL)) {\n            throw new Error(\"Invalid DATABASE_URL format. Expected postgresql:// or postgres:// URL\");\n        }\n        console.log(\"DATABASE_URL is valid, creating Neon connection...\");\n        sql = (0,_neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__.neon)(process.env.DATABASE_URL);\n        neonReady = true;\n        console.log(\"Neon connection created successfully\");\n    } else {\n        console.warn(\"âš ï¸  DATABASE_URL environment variable not found!\");\n        console.warn(\"âš ï¸  Using in-memory storage - data will be lost on restart\");\n        console.warn(\"âš ï¸  To persist data, create a .env file with DATABASE_URL\");\n        connectionError = \"DATABASE_URL environment variable not found\";\n    }\n} catch (e) {\n    console.error(\"âŒ Neon connection initialization error:\", e);\n    console.warn(\"âš ï¸  Falling back to in-memory storage - data will be lost on restart\");\n    connectionError = e instanceof Error ? e.message : \"Unknown connection error\";\n    neonReady = false;\n}\n// TEST MODE: Simulate database connection for testing (only if no DATABASE_URL)\nif (!neonReady && \"development\" === 'development' && !process.env.DATABASE_URL) {\n    console.log(\"ðŸ§ª TEST MODE: Simulating database connection...\");\n    neonReady = true;\n    connectionError = null;\n    console.log(\"âœ… Test mode: Database connection simulated\");\n}\n/* ------------------------------------------------------------------ */ /*  One-time table creation promise                                   */ /* ------------------------------------------------------------------ */ async function createTables() {\n    if (!neonReady || !sql) {\n        console.log(\"Skipping table creation - Neon not ready\");\n        return;\n    }\n    try {\n        console.log(\"Creating tables if they don't exist...\");\n        // Create table first\n        await sql(_templateObject());\n        // Create indexes separately\n        await sql(_templateObject1());\n        await sql(_templateObject2());\n        console.log(\"Neon: ahp_evaluations table and indexes created successfully\");\n    } catch (error) {\n        console.error(\"Table creation error:\", error);\n        throw error;\n    }\n}\nconst initPromise = neonReady ? createTables() : Promise.resolve();\n/* ------------------------------------------------------------------ */ /*  In-memory storage (used when Neon isn't configured)               */ /* ------------------------------------------------------------------ */ const mem = [];\nconst memFindByUser = (u)=>{\n    var _mem_find;\n    return (_mem_find = mem.find((e)=>e.user_name === u)) !== null && _mem_find !== void 0 ? _mem_find : null;\n};\nconst memSave = (row)=>{\n    const i = mem.findIndex((e)=>e.user_name === row.user_name);\n    i === -1 ? mem.push(row) : mem[i] = row;\n    return row;\n};\n/* ------------------------------------------------------------------ */ /*  Public helpers                                                    */ /* ------------------------------------------------------------------ */ async function initializeDatabase() {\n    try {\n        await initPromise;\n        console.log(\"Database initialization completed\");\n    } catch (error) {\n        console.error(\"Database initialization failed:\", error);\n        throw error;\n    }\n}\n/* CREATE / UPDATE (upsert by user) */ async function saveAHPEvaluation(userName, criteriaWeights, globalWeights, consistencyResults, hierarchyData) {\n    const now = new Date().toISOString();\n    /* In-memory mode -------------------------------------------------- */ if (!neonReady) {\n        console.warn(\"âš ï¸  Neon DB not ready (\".concat(connectionError, \"), saving to in-memory for user: \").concat(userName));\n        console.warn(\"âš ï¸  This data will be LOST when the application restarts!\");\n        const row = {\n            id: generateId(),\n            user_name: userName,\n            criteria_weights: criteriaWeights,\n            global_weights: globalWeights,\n            consistency_results: consistencyResults,\n            hierarchy_data: hierarchyData,\n            created_at: now,\n            updated_at: now\n        };\n        return memSave(row);\n    }\n    /* Neon mode ------------------------------------------------------- */ try {\n        await initPromise;\n        console.log(\"Checking for existing evaluation for user: \".concat(userName));\n        const existing = await sql(_templateObject3(), userName);\n        if (existing.length) {\n            console.log(\"Updating existing evaluation for user: \".concat(userName));\n            const res = await sql(_templateObject4(), JSON.stringify(criteriaWeights), JSON.stringify(globalWeights), JSON.stringify(consistencyResults), JSON.stringify(hierarchyData), now, userName);\n            console.log(\"Neon: Updated evaluation for user \".concat(userName));\n            return parseRow(res[0]);\n        }\n        console.log(\"Creating new evaluation for user: \".concat(userName));\n        const res = await sql(_templateObject5(), generateId(), userName, JSON.stringify(criteriaWeights), JSON.stringify(globalWeights), JSON.stringify(consistencyResults), JSON.stringify(hierarchyData), now, now);\n        console.log(\"Neon: Inserted new evaluation for user \".concat(userName));\n        return parseRow(res[0]);\n    } catch (error) {\n        console.error(\"AHP kaydetme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            stack: error.stack,\n            userName,\n            connectionError\n        });\n        throw error;\n    }\n}\n/* READ - all */ async function getAllAHPEvaluations() {\n    if (!neonReady) {\n        console.warn(\"âš ï¸  Neon DB not ready (\".concat(connectionError, \"), getting all from in-memory. Count: \").concat(mem.length));\n        console.warn(\"âš ï¸  In-memory data will be LOST when the application restarts!\");\n        return [\n            ...mem\n        ] // Return a copy to avoid mutations\n        ;\n    }\n    try {\n        await initPromise;\n        console.log(\"Fetching all evaluations from Neon...\");\n        const res = await sql(_templateObject6());\n        console.log(\"Neon: Fetched \".concat(res.length, \" evaluations\"));\n        return res.map(parseRow);\n    } catch (error) {\n        console.error(\"AHP verilerini getirme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            stack: error.stack,\n            connectionError,\n            neonReady\n        });\n        // Fallback to in-memory if database fails\n        console.log(\"Falling back to in-memory storage due to database error\");\n        return [\n            ...mem\n        ];\n    }\n}\n/* READ - by user */ async function getAHPEvaluationByUser(userName) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), getting by user from in-memory: \").concat(userName));\n        return memFindByUser(userName);\n    }\n    try {\n        await initPromise;\n        console.log(\"Fetching evaluation for user: \".concat(userName));\n        const res = await sql(_templateObject7(), userName);\n        console.log(\"Neon: Fetched evaluation for user \".concat(userName, \". Found: \").concat(res.length > 0));\n        return res.length ? parseRow(res[0]) : null;\n    } catch (error) {\n        console.error(\"KullanÄ±cÄ± AHP verisi getirme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            userName,\n            connectionError\n        });\n        // Fallback to in-memory\n        return memFindByUser(userName);\n    }\n}\n/* DELETE single */ async function deleteAHPEvaluation(id) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting from in-memory: \").concat(id));\n        const i = mem.findIndex((e)=>e.id === id);\n        if (i !== -1) {\n            mem.splice(i, 1);\n            console.log(\"Deleted from in-memory. Remaining count: \".concat(mem.length));\n            return true;\n        }\n        console.log(\"Item not found in in-memory storage\");\n        return false;\n    }\n    try {\n        await initPromise;\n        console.log(\"Deleting evaluation with ID: \".concat(id));\n        const result = await sql(_templateObject8(), id);\n        const deleted = result.length > 0;\n        console.log(\"Neon: Delete operation completed. Deleted: \".concat(deleted));\n        return deleted;\n    } catch (error) {\n        console.error(\"Neon: Error deleting single evaluation with ID \".concat(id, \":\"), error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            id,\n            connectionError\n        });\n        return false;\n    }\n}\n/* DELETE multiple */ async function deleteMultipleAHPEvaluations(evaluationIds) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting multiple from in-memory: \").concat(evaluationIds.length, \" items\"));\n        let deletedCount = 0;\n        evaluationIds.forEach((id)=>{\n            const i = mem.findIndex((r)=>r.id === id);\n            if (i !== -1) {\n                mem.splice(i, 1);\n                deletedCount++;\n            }\n        });\n        console.log(\"Deleted \".concat(deletedCount, \" items from in-memory. Remaining count: \").concat(mem.length));\n        return deletedCount > 0;\n    }\n    try {\n        if (evaluationIds.length === 0) {\n            console.log(\"Neon: No evaluation IDs provided for multiple delete\");\n            return true;\n        }\n        await initPromise;\n        console.log(\"Deleting multiple evaluations: \".concat(evaluationIds.length, \" items\"));\n        const result = await sql(_templateObject9(), evaluationIds);\n        const deletedCount = result.length;\n        console.log(\"Neon: Deleted \".concat(deletedCount, \" out of \").concat(evaluationIds.length, \" evaluations\"));\n        return deletedCount > 0;\n    } catch (error) {\n        console.error(\"Neon: Error deleting multiple evaluations:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            evaluationIds,\n            connectionError\n        });\n        return false;\n    }\n}\n/* DELETE all */ async function deleteAllAHPEvaluations() {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting all from in-memory\"));\n        const previousCount = mem.length;\n        mem.length = 0;\n        console.log(\"Deleted all \".concat(previousCount, \" items from in-memory\"));\n        return true;\n    }\n    try {\n        await initPromise;\n        console.log(\"Deleting all evaluations from Neon...\");\n        const result = await sql(_templateObject10());\n        const deletedCount = result.length;\n        console.log(\"Neon: Deleted all \".concat(deletedCount, \" evaluations\"));\n        return true;\n    } catch (error) {\n        console.error(\"Neon: Error deleting all evaluations:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            connectionError\n        });\n        return false;\n    }\n}\n/* Calculate average weights */ function calculateAverageWeights(evaluations) {\n    if (evaluations.length === 0) return {};\n    const allWeights = evaluations.map((evaluation)=>evaluation.global_weights);\n    const criteriaIds = Object.keys(allWeights[0] || {});\n    const averageWeights = {};\n    criteriaIds.forEach((criteriaId)=>{\n        const weights = allWeights.map((w)=>w[criteriaId] || 0);\n        averageWeights[criteriaId] = weights.reduce((sum, weight)=>sum + weight, 0) / weights.length;\n    });\n    return averageWeights;\n}\n/* Storage stats */ async function getStorageStats() {\n    if (!neonReady) {\n        return {\n            totalEvaluations: mem.length,\n            lastUpdated: mem.length > 0 ? mem.sort((a, b)=>new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime())[0].updated_at : null,\n            storage: \"in-memory\",\n            connectionError\n        };\n    }\n    try {\n        await initPromise;\n        const result = await sql(_templateObject11());\n        return {\n            totalEvaluations: Number(result[0].total_evaluations),\n            lastUpdated: result[0].last_updated,\n            storage: \"neon\",\n            connectionError: null\n        };\n    } catch (error) {\n        console.error(\"Ä°statistik alma hatasÄ±:\", error);\n        return {\n            totalEvaluations: 0,\n            lastUpdated: null,\n            storage: \"error\",\n            connectionError: error.message\n        };\n    }\n}\n/* Database connection check */ async function checkDatabaseConnection() {\n    if (!neonReady) {\n        console.log(\"Database connection check failed: \".concat(connectionError));\n        return false;\n    }\n    try {\n        await initPromise;\n        // Test the connection with a simple query\n        await sql(_templateObject12());\n        console.log(\"Database connection test successful\");\n        return true;\n    } catch (error) {\n        console.error(\"Database connection test failed:\", error);\n        return false;\n    }\n}\n/* Simple connection status check (without actual query) */ function isDatabaseReady() {\n    return neonReady && sql !== null;\n}\n/* ------------------------------------------------------------------ */ /*  Utility                                                           */ /* ------------------------------------------------------------------ */ function parseRow(row) {\n    const safeJsonParse = function(value) {\n        let fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (typeof value === \"object\" && value !== null) {\n            return value // Already parsed\n            ;\n        }\n        if (typeof value === \"string\") {\n            try {\n                return JSON.parse(value);\n            } catch (error) {\n                console.error(\"JSON parse error for value:\", value, error);\n                return fallback;\n            }\n        }\n        return fallback;\n    };\n    return {\n        id: row.id,\n        user_name: row.user_name,\n        criteria_weights: safeJsonParse(row.criteria_weights, {}),\n        global_weights: safeJsonParse(row.global_weights, {}),\n        consistency_results: safeJsonParse(row.consistency_results, {}),\n        hierarchy_data: safeJsonParse(row.hierarchy_data, {}),\n        created_at: row.created_at,\n        updated_at: row.updated_at\n    };\n}\nfunction generateId() {\n    return Date.now().toString(36) + Math.random().toString(36).slice(2);\n}\n// Export connection status for debugging\nfunction getConnectionStatus() {\n    return {\n        neonReady,\n        connectionError,\n        hasEnvironmentUrl: !!process.env.DATABASE_URL,\n        urlValid: process.env.DATABASE_URL ? validateDatabaseUrl(process.env.DATABASE_URL) : false\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uZW9uLWRiLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFFL0Msc0VBQXNFLEdBQ3RFLHNFQUFzRSxHQUN0RSxzRUFBc0UsR0FDdEUsSUFBSUMsTUFBc0M7QUFDMUMsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxrQkFBaUM7QUFFckMsMEJBQTBCO0FBQzFCLFNBQVNDLG9CQUFvQkMsR0FBVztJQUN0QyxJQUFJO1FBQ0YsMERBQTBEO1FBQzFELElBQUksQ0FBQ0EsSUFBSUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDRCxJQUFJQyxVQUFVLENBQUMsZ0JBQWdCO1lBQ3RFLE9BQU87UUFDVDtRQUVBLHVCQUF1QjtRQUN2QixNQUFNQyxTQUFTLElBQUlDLElBQUlIO1FBQ3ZCLE9BQU9FLE9BQU9FLFFBQVEsSUFBSUYsT0FBT0csUUFBUTtJQUMzQyxFQUFFLFVBQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUVBLElBQUk7SUFDRixJQUFJQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLFlBQVksRUFBRTtRQUM1QkMsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSSxDQUFDWCxvQkFBb0JPLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWSxHQUFHO1lBQ2xELE1BQU0sSUFBSUcsTUFBTTtRQUNsQjtRQUVBRixRQUFRQyxHQUFHLENBQUM7UUFDWmQsTUFBTUQsOERBQUlBLENBQUNXLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWTtRQUNuQ1gsWUFBWTtRQUNaWSxRQUFRQyxHQUFHLENBQUM7SUFDZCxPQUFPO1FBQ0xELFFBQVFHLElBQUksQ0FBQztRQUNiSCxRQUFR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O1lBQ3BCLEVBQUUsT0FBT25GLE9BQU87Z0JBQ2RMLFFBQVFLLEtBQUssQ0FBQywrQkFBK0JtRixPQUFPbkY7Z0JBQ3BELE9BQU9vRjtZQUNUO1FBQ0Y7UUFFQSxPQUFPQTtJQUNUO0lBRUEsT0FBTztRQUNMMUQsSUFBSWQsSUFBSWMsRUFBRTtRQUNWaEIsV0FBV0UsSUFBSUYsU0FBUztRQUN4QmtCLGtCQUFrQnNELGNBQWN0RSxJQUFJZ0IsZ0JBQWdCLEVBQUUsQ0FBQztRQUN2REMsZ0JBQWdCcUQsY0FBY3RFLElBQUlpQixjQUFjLEVBQUUsQ0FBQztRQUNuREMscUJBQXFCb0QsY0FBY3RFLElBQUlrQixtQkFBbUIsRUFBRSxDQUFDO1FBQzdEQyxnQkFBZ0JtRCxjQUFjdEUsSUFBSW1CLGNBQWMsRUFBRSxDQUFDO1FBQ25EQyxZQUFZcEIsSUFBSW9CLFVBQVU7UUFDMUJDLFlBQVlyQixJQUFJcUIsVUFBVTtJQUM1QjtBQUNGO0FBRUEsU0FBU047SUFDUCxPQUFPSCxLQUFLRCxHQUFHLEdBQUcrRCxRQUFRLENBQUMsTUFBTUMsS0FBS0MsTUFBTSxHQUFHRixRQUFRLENBQUMsSUFBSUcsS0FBSyxDQUFDO0FBQ3BFO0FBRUEseUNBQXlDO0FBQ2xDLFNBQVNDO0lBQ2QsT0FBTztRQUNMM0c7UUFDQUM7UUFDQTJHLG1CQUFtQixDQUFDLENBQUNuRyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLFlBQVk7UUFDN0NrRyxVQUFVcEcsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxZQUFZLEdBQUdULG9CQUFvQk8sT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxZQUFZLElBQUk7SUFDdkY7QUFDRiIsInNvdXJjZXMiOlsiRDpcXFN1cnVjdXB1YW5zaXN0ZW1pMDgyMDI1XFxTUFNfRGlzaXBsaW5BeXItbWwtXzA0MDkyMDI1XFxsaWJcXG5lb24tZGIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbmVvbiB9IGZyb20gXCJAbmVvbmRhdGFiYXNlL3NlcnZlcmxlc3NcIlxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBOZW9uIGNvbm5lY3Rpb24gKG9yIGluLW1lbW9yeSBmYWxsYmFjaykgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxubGV0IHNxbDogUmV0dXJuVHlwZTx0eXBlb2YgbmVvbj4gfCBudWxsID0gbnVsbFxyXG5sZXQgbmVvblJlYWR5ID0gZmFsc2VcclxubGV0IGNvbm5lY3Rpb25FcnJvcjogc3RyaW5nIHwgbnVsbCA9IG51bGxcclxuXHJcbi8vIERBVEFCQVNFX1VSTCB2YWxpZGF0aW9uXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGF0YWJhc2VVcmwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICB0cnkge1xyXG4gICAgLy8gTmVvbiBVUkwgc2hvdWxkIHN0YXJ0IHdpdGggcG9zdGdyZXNxbDovLyBvciBwb3N0Z3JlczovL1xyXG4gICAgaWYgKCF1cmwuc3RhcnRzV2l0aChcInBvc3RncmVzcWw6Ly9cIikgJiYgIXVybC5zdGFydHNXaXRoKFwicG9zdGdyZXM6Ly9cIikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmFzaWMgVVJMIHZhbGlkYXRpb25cclxuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKVxyXG4gICAgcmV0dXJuIHVybE9iai5ob3N0bmFtZSAmJiB1cmxPYmoucGF0aG5hbWVcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxudHJ5IHtcclxuICBpZiAocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkRBVEFCQVNFX1VSTCBmb3VuZCwgdmFsaWRhdGluZy4uLlwiKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVEYXRhYmFzZVVybChwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkwpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgREFUQUJBU0VfVVJMIGZvcm1hdC4gRXhwZWN0ZWQgcG9zdGdyZXNxbDovLyBvciBwb3N0Z3JlczovLyBVUkxcIilcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkRBVEFCQVNFX1VSTCBpcyB2YWxpZCwgY3JlYXRpbmcgTmVvbiBjb25uZWN0aW9uLi4uXCIpXHJcbiAgICBzcWwgPSBuZW9uKHByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTClcclxuICAgIG5lb25SZWFkeSA9IHRydWVcclxuICAgIGNvbnNvbGUubG9nKFwiTmVvbiBjb25uZWN0aW9uIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5XCIpXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyAgREFUQUJBU0VfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlIG5vdCBmb3VuZCFcIilcclxuICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyAgVXNpbmcgaW4tbWVtb3J5IHN0b3JhZ2UgLSBkYXRhIHdpbGwgYmUgbG9zdCBvbiByZXN0YXJ0XCIpXHJcbiAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gIFRvIHBlcnNpc3QgZGF0YSwgY3JlYXRlIGEgLmVudiBmaWxlIHdpdGggREFUQUJBU0VfVVJMXCIpXHJcbiAgICBjb25uZWN0aW9uRXJyb3IgPSBcIkRBVEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZSBub3QgZm91bmRcIlxyXG4gIH1cclxufSBjYXRjaCAoZSkge1xyXG4gIGNvbnNvbGUuZXJyb3IoXCLinYwgTmVvbiBjb25uZWN0aW9uIGluaXRpYWxpemF0aW9uIGVycm9yOlwiLCBlKVxyXG4gIGNvbnNvbGUud2FybihcIuKaoO+4jyAgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIC0gZGF0YSB3aWxsIGJlIGxvc3Qgb24gcmVzdGFydFwiKVxyXG4gIGNvbm5lY3Rpb25FcnJvciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFwiVW5rbm93biBjb25uZWN0aW9uIGVycm9yXCJcclxuICBuZW9uUmVhZHkgPSBmYWxzZVxyXG59XHJcblxyXG4vLyBURVNUIE1PREU6IFNpbXVsYXRlIGRhdGFiYXNlIGNvbm5lY3Rpb24gZm9yIHRlc3RpbmcgKG9ubHkgaWYgbm8gREFUQUJBU0VfVVJMKVxyXG5pZiAoIW5lb25SZWFkeSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSB7XHJcbiAgY29uc29sZS5sb2coXCLwn6eqIFRFU1QgTU9ERTogU2ltdWxhdGluZyBkYXRhYmFzZSBjb25uZWN0aW9uLi4uXCIpXHJcbiAgbmVvblJlYWR5ID0gdHJ1ZVxyXG4gIGNvbm5lY3Rpb25FcnJvciA9IG51bGxcclxuICBjb25zb2xlLmxvZyhcIuKchSBUZXN0IG1vZGU6IERhdGFiYXNlIGNvbm5lY3Rpb24gc2ltdWxhdGVkXCIpXHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgT25lLXRpbWUgdGFibGUgY3JlYXRpb24gcHJvbWlzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlcygpIHtcclxuICBpZiAoIW5lb25SZWFkeSB8fCAhc3FsKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlNraXBwaW5nIHRhYmxlIGNyZWF0aW9uIC0gTmVvbiBub3QgcmVhZHlcIilcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgdGFibGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3QuLi5cIilcclxuXHJcbiAgICAvLyBDcmVhdGUgdGFibGUgZmlyc3RcclxuICAgIGF3YWl0IHNxbGBcclxuICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgYWhwX2V2YWx1YXRpb25zIChcclxuICAgICAgICBpZCBURVhUIFBSSU1BUlkgS0VZLFxyXG4gICAgICAgIHVzZXJfbmFtZSBURVhUIE5PVCBOVUxMLFxyXG4gICAgICAgIGNyaXRlcmlhX3dlaWdodHMgSlNPTkIgTk9UIE5VTEwsXHJcbiAgICAgICAgZ2xvYmFsX3dlaWdodHMgSlNPTkIgTk9UIE5VTEwsXHJcbiAgICAgICAgY29uc2lzdGVuY3lfcmVzdWx0cyBKU09OQiBOT1QgTlVMTCxcclxuICAgICAgICBoaWVyYXJjaHlfZGF0YSBKU09OQiBOT1QgTlVMTCxcclxuICAgICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKClcclxuICAgICAgKVxyXG4gICAgYFxyXG5cclxuICAgIC8vIENyZWF0ZSBpbmRleGVzIHNlcGFyYXRlbHlcclxuICAgIGF3YWl0IHNxbGBcclxuICAgICAgQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2FocF9ldmFsdWF0aW9uc191c2VyX25hbWVcclxuICAgICAgT04gYWhwX2V2YWx1YXRpb25zKHVzZXJfbmFtZSlcclxuICAgIGBcclxuXHJcbiAgICBhd2FpdCBzcWxgXHJcbiAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9haHBfZXZhbHVhdGlvbnNfdXBkYXRlZF9hdFxyXG4gICAgICBPTiBhaHBfZXZhbHVhdGlvbnModXBkYXRlZF9hdClcclxuICAgIGBcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIk5lb246IGFocF9ldmFsdWF0aW9ucyB0YWJsZSBhbmQgaW5kZXhlcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiVGFibGUgY3JlYXRpb24gZXJyb3I6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gbmVvblJlYWR5ID8gY3JlYXRlVGFibGVzKCkgOiBQcm9taXNlLnJlc29sdmUoKVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBUeXBlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBSFBFdmFsdWF0aW9uIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdXNlcl9uYW1lOiBzdHJpbmdcclxuICBjcml0ZXJpYV93ZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+XHJcbiAgZ2xvYmFsX3dlaWdodHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxuICBjb25zaXN0ZW5jeV9yZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgaGllcmFyY2h5X2RhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcltdW10+XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgSW4tbWVtb3J5IHN0b3JhZ2UgKHVzZWQgd2hlbiBOZW9uIGlzbid0IGNvbmZpZ3VyZWQpICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmNvbnN0IG1lbTogQUhQRXZhbHVhdGlvbltdID0gW11cclxuY29uc3QgbWVtRmluZEJ5VXNlciA9ICh1OiBzdHJpbmcpID0+IG1lbS5maW5kKChlKSA9PiBlLnVzZXJfbmFtZSA9PT0gdSkgPz8gbnVsbFxyXG5jb25zdCBtZW1TYXZlID0gKHJvdzogQUhQRXZhbHVhdGlvbikgPT4ge1xyXG4gIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChlKSA9PiBlLnVzZXJfbmFtZSA9PT0gcm93LnVzZXJfbmFtZSlcclxuICBpID09PSAtMSA/IG1lbS5wdXNoKHJvdykgOiAobWVtW2ldID0gcm93KVxyXG4gIHJldHVybiByb3dcclxufVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBQdWJsaWMgaGVscGVycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVEYXRhYmFzZSgpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgaW5pdFByb21pc2VcclxuICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2UgaW5pdGlhbGl6YXRpb24gY29tcGxldGVkXCIpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbi8qIENSRUFURSAvIFVQREFURSAodXBzZXJ0IGJ5IHVzZXIpICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlQUhQRXZhbHVhdGlvbihcclxuICB1c2VyTmFtZTogc3RyaW5nLFxyXG4gIGNyaXRlcmlhV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcclxuICBnbG9iYWxXZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxyXG4gIGNvbnNpc3RlbmN5UmVzdWx0czogUmVjb3JkPHN0cmluZywgYW55PixcclxuICBoaWVyYXJjaHlEYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXVtdPixcclxuKTogUHJvbWlzZTxBSFBFdmFsdWF0aW9uPiB7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcblxyXG4gIC8qIEluLW1lbW9yeSBtb2RlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgc2F2aW5nIHRvIGluLW1lbW9yeSBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc29sZS53YXJuKGDimqDvuI8gIFRoaXMgZGF0YSB3aWxsIGJlIExPU1Qgd2hlbiB0aGUgYXBwbGljYXRpb24gcmVzdGFydHMhYClcclxuICAgIGNvbnN0IHJvdzogQUhQRXZhbHVhdGlvbiA9IHtcclxuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgICAgdXNlcl9uYW1lOiB1c2VyTmFtZSxcclxuICAgICAgY3JpdGVyaWFfd2VpZ2h0czogY3JpdGVyaWFXZWlnaHRzLFxyXG4gICAgICBnbG9iYWxfd2VpZ2h0czogZ2xvYmFsV2VpZ2h0cyxcclxuICAgICAgY29uc2lzdGVuY3lfcmVzdWx0czogY29uc2lzdGVuY3lSZXN1bHRzLFxyXG4gICAgICBoaWVyYXJjaHlfZGF0YTogaGllcmFyY2h5RGF0YSxcclxuICAgICAgY3JlYXRlZF9hdDogbm93LFxyXG4gICAgICB1cGRhdGVkX2F0OiBub3csXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVtU2F2ZShyb3cpXHJcbiAgfVxyXG5cclxuICAvKiBOZW9uIG1vZGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBmb3IgZXhpc3RpbmcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBzcWwhYFxyXG4gICAgICBTRUxFQ1QgaWQgRlJPTSBhaHBfZXZhbHVhdGlvbnMgV0hFUkUgdXNlcl9uYW1lID0gJHt1c2VyTmFtZX1cclxuICAgIGBcclxuXHJcbiAgICBpZiAoZXhpc3RpbmcubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBleGlzdGluZyBldmFsdWF0aW9uIGZvciB1c2VyOiAke3VzZXJOYW1lfWApXHJcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHNxbCFgXHJcbiAgICAgICAgVVBEQVRFIGFocF9ldmFsdWF0aW9ucyBTRVRcclxuICAgICAgICAgIGNyaXRlcmlhX3dlaWdodHMgICA9ICR7SlNPTi5zdHJpbmdpZnkoY3JpdGVyaWFXZWlnaHRzKX0sXHJcbiAgICAgICAgICBnbG9iYWxfd2VpZ2h0cyAgICAgPSAke0pTT04uc3RyaW5naWZ5KGdsb2JhbFdlaWdodHMpfSxcclxuICAgICAgICAgIGNvbnNpc3RlbmN5X3Jlc3VsdHM9ICR7SlNPTi5zdHJpbmdpZnkoY29uc2lzdGVuY3lSZXN1bHRzKX0sXHJcbiAgICAgICAgICBoaWVyYXJjaHlfZGF0YSAgICAgPSAke0pTT04uc3RyaW5naWZ5KGhpZXJhcmNoeURhdGEpfSxcclxuICAgICAgICAgIHVwZGF0ZWRfYXQgICAgICAgICA9ICR7bm93fVxyXG4gICAgICAgIFdIRVJFIHVzZXJfbmFtZSAgICAgID0gJHt1c2VyTmFtZX1cclxuICAgICAgICBSRVRVUk5JTkcgKlxyXG4gICAgICBgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBOZW9uOiBVcGRhdGVkIGV2YWx1YXRpb24gZm9yIHVzZXIgJHt1c2VyTmFtZX1gKVxyXG4gICAgICByZXR1cm4gcGFyc2VSb3cocmVzWzBdKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBuZXcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3FsIWBcclxuICAgICAgSU5TRVJUIElOVE8gYWhwX2V2YWx1YXRpb25zIChcclxuICAgICAgICBpZCwgdXNlcl9uYW1lLCBjcml0ZXJpYV93ZWlnaHRzLCBnbG9iYWxfd2VpZ2h0cyxcclxuICAgICAgICBjb25zaXN0ZW5jeV9yZXN1bHRzLCBoaWVyYXJjaHlfZGF0YSwgY3JlYXRlZF9hdCwgdXBkYXRlZF9hdFxyXG4gICAgICApIFZBTFVFUyAoXHJcbiAgICAgICAgJHtnZW5lcmF0ZUlkKCl9LCAke3VzZXJOYW1lfSwgJHtKU09OLnN0cmluZ2lmeShjcml0ZXJpYVdlaWdodHMpfSwgJHtKU09OLnN0cmluZ2lmeShnbG9iYWxXZWlnaHRzKX0sXHJcbiAgICAgICAgJHtKU09OLnN0cmluZ2lmeShjb25zaXN0ZW5jeVJlc3VsdHMpfSwgJHtKU09OLnN0cmluZ2lmeShoaWVyYXJjaHlEYXRhKX0sICR7bm93fSwgJHtub3d9XHJcbiAgICAgIClcclxuICAgICAgUkVUVVJOSU5HICpcclxuICAgIGBcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBJbnNlcnRlZCBuZXcgZXZhbHVhdGlvbiBmb3IgdXNlciAke3VzZXJOYW1lfWApXHJcbiAgICByZXR1cm4gcGFyc2VSb3cocmVzWzBdKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiQUhQIGtheWRldG1lIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICB1c2VyTmFtZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG4vKiBSRUFEIC0gYWxsICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxBSFBFdmFsdWF0aW9ucygpOiBQcm9taXNlPEFIUEV2YWx1YXRpb25bXT4ge1xyXG4gIGlmICghbmVvblJlYWR5KSB7XHJcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgTmVvbiBEQiBub3QgcmVhZHkgKCR7Y29ubmVjdGlvbkVycm9yfSksIGdldHRpbmcgYWxsIGZyb20gaW4tbWVtb3J5LiBDb3VudDogJHttZW0ubGVuZ3RofWApXHJcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgSW4tbWVtb3J5IGRhdGEgd2lsbCBiZSBMT1NUIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlc3RhcnRzIWApXHJcbiAgICByZXR1cm4gWy4uLm1lbV0gLy8gUmV0dXJuIGEgY29weSB0byBhdm9pZCBtdXRhdGlvbnNcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coXCJGZXRjaGluZyBhbGwgZXZhbHVhdGlvbnMgZnJvbSBOZW9uLi4uXCIpXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBzcWwhYFNFTEVDVCAqIEZST00gYWhwX2V2YWx1YXRpb25zIE9SREVSIEJZIHVwZGF0ZWRfYXQgREVTQ2BcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBGZXRjaGVkICR7cmVzLmxlbmd0aH0gZXZhbHVhdGlvbnNgKVxyXG4gICAgcmV0dXJuIHJlcy5tYXAocGFyc2VSb3cpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJBSFAgdmVyaWxlcmluaSBnZXRpcm1lIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3IsXHJcbiAgICAgIG5lb25SZWFkeSxcclxuICAgIH0pXHJcblxyXG4gICAgLy8gRmFsbGJhY2sgdG8gaW4tbWVtb3J5IGlmIGRhdGFiYXNlIGZhaWxzXHJcbiAgICBjb25zb2xlLmxvZyhcIkZhbGxpbmcgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZSBkdWUgdG8gZGF0YWJhc2UgZXJyb3JcIilcclxuICAgIHJldHVybiBbLi4ubWVtXVxyXG4gIH1cclxufVxyXG5cclxuLyogUkVBRCAtIGJ5IHVzZXIgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFIUEV2YWx1YXRpb25CeVVzZXIodXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8QUhQRXZhbHVhdGlvbiB8IG51bGw+IHtcclxuICBpZiAoIW5lb25SZWFkeSkge1xyXG4gICAgY29uc29sZS5sb2coYE5lb24gREIgbm90IHJlYWR5ICgke2Nvbm5lY3Rpb25FcnJvcn0pLCBnZXR0aW5nIGJ5IHVzZXIgZnJvbSBpbi1tZW1vcnk6ICR7dXNlck5hbWV9YClcclxuICAgIHJldHVybiBtZW1GaW5kQnlVc2VyKHVzZXJOYW1lKVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRQcm9taXNlXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3FsIWBTRUxFQ1QgKiBGUk9NIGFocF9ldmFsdWF0aW9ucyBXSEVSRSB1c2VyX25hbWUgPSAke3VzZXJOYW1lfWBcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBGZXRjaGVkIGV2YWx1YXRpb24gZm9yIHVzZXIgJHt1c2VyTmFtZX0uIEZvdW5kOiAke3Jlcy5sZW5ndGggPiAwfWApXHJcbiAgICByZXR1cm4gcmVzLmxlbmd0aCA/IHBhcnNlUm93KHJlc1swXSkgOiBudWxsXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJLdWxsYW7EsWPEsSBBSFAgdmVyaXNpIGdldGlybWUgaGF0YXPEsTpcIiwgZXJyb3IpXHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGV0YWlsczpcIiwge1xyXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICB1c2VyTmFtZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBpbi1tZW1vcnlcclxuICAgIHJldHVybiBtZW1GaW5kQnlVc2VyKHVzZXJOYW1lKVxyXG4gIH1cclxufVxyXG5cclxuLyogREVMRVRFIHNpbmdsZSAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQUhQRXZhbHVhdGlvbihpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgZnJvbSBpbi1tZW1vcnk6ICR7aWR9YClcclxuICAgIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChlKSA9PiBlLmlkID09PSBpZClcclxuICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICBtZW0uc3BsaWNlKGksIDEpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBEZWxldGVkIGZyb20gaW4tbWVtb3J5LiBSZW1haW5pbmcgY291bnQ6ICR7bWVtLmxlbmd0aH1gKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJJdGVtIG5vdCBmb3VuZCBpbiBpbi1tZW1vcnkgc3RvcmFnZVwiKVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgYXdhaXQgaW5pdFByb21pc2VcclxuICAgIGNvbnNvbGUubG9nKGBEZWxldGluZyBldmFsdWF0aW9uIHdpdGggSUQ6ICR7aWR9YClcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbCFgREVMRVRFIEZST00gYWhwX2V2YWx1YXRpb25zIFdIRVJFIGlkID0gJHtpZH0gUkVUVVJOSU5HIGlkYFxyXG4gICAgY29uc3QgZGVsZXRlZCA9IHJlc3VsdC5sZW5ndGggPiAwXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlIG9wZXJhdGlvbiBjb21wbGV0ZWQuIERlbGV0ZWQ6ICR7ZGVsZXRlZH1gKVxyXG4gICAgcmV0dXJuIGRlbGV0ZWRcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgTmVvbjogRXJyb3IgZGVsZXRpbmcgc2luZ2xlIGV2YWx1YXRpb24gd2l0aCBJRCAke2lkfTpgLCBlcnJvcilcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXRhaWxzOlwiLCB7XHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIGlkLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3IsXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG4vKiBERUxFVEUgbXVsdGlwbGUgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU11bHRpcGxlQUhQRXZhbHVhdGlvbnMoZXZhbHVhdGlvbklkczogc3RyaW5nW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBpZiAoIW5lb25SZWFkeSkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgbXVsdGlwbGUgZnJvbSBpbi1tZW1vcnk6ICR7ZXZhbHVhdGlvbklkcy5sZW5ndGh9IGl0ZW1zYCxcclxuICAgIClcclxuICAgIGxldCBkZWxldGVkQ291bnQgPSAwXHJcbiAgICBldmFsdWF0aW9uSWRzLmZvckVhY2goKGlkKSA9PiB7XHJcbiAgICAgIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChyKSA9PiByLmlkID09PSBpZClcclxuICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgbWVtLnNwbGljZShpLCAxKVxyXG4gICAgICAgIGRlbGV0ZWRDb3VudCsrXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICBjb25zb2xlLmxvZyhgRGVsZXRlZCAke2RlbGV0ZWRDb3VudH0gaXRlbXMgZnJvbSBpbi1tZW1vcnkuIFJlbWFpbmluZyBjb3VudDogJHttZW0ubGVuZ3RofWApXHJcbiAgICByZXR1cm4gZGVsZXRlZENvdW50ID4gMFxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGlmIChldmFsdWF0aW9uSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIk5lb246IE5vIGV2YWx1YXRpb24gSURzIHByb3ZpZGVkIGZvciBtdWx0aXBsZSBkZWxldGVcIilcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coYERlbGV0aW5nIG11bHRpcGxlIGV2YWx1YXRpb25zOiAke2V2YWx1YXRpb25JZHMubGVuZ3RofSBpdGVtc2ApXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWwhYERFTEVURSBGUk9NIGFocF9ldmFsdWF0aW9ucyBXSEVSRSBpZCA9IEFOWSgke2V2YWx1YXRpb25JZHN9KSBSRVRVUk5JTkcgaWRgXHJcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSByZXN1bHQubGVuZ3RoXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlZCAke2RlbGV0ZWRDb3VudH0gb3V0IG9mICR7ZXZhbHVhdGlvbklkcy5sZW5ndGh9IGV2YWx1YXRpb25zYClcclxuICAgIHJldHVybiBkZWxldGVkQ291bnQgPiAwXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYE5lb246IEVycm9yIGRlbGV0aW5nIG11bHRpcGxlIGV2YWx1YXRpb25zOmAsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgZXZhbHVhdGlvbklkcyxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogREVMRVRFIGFsbCAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsQUhQRXZhbHVhdGlvbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgYWxsIGZyb20gaW4tbWVtb3J5YClcclxuICAgIGNvbnN0IHByZXZpb3VzQ291bnQgPSBtZW0ubGVuZ3RoXHJcbiAgICBtZW0ubGVuZ3RoID0gMFxyXG4gICAgY29uc29sZS5sb2coYERlbGV0ZWQgYWxsICR7cHJldmlvdXNDb3VudH0gaXRlbXMgZnJvbSBpbi1tZW1vcnlgKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coXCJEZWxldGluZyBhbGwgZXZhbHVhdGlvbnMgZnJvbSBOZW9uLi4uXCIpXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWwhYERFTEVURSBGUk9NIGFocF9ldmFsdWF0aW9ucyBSRVRVUk5JTkcgaWRgXHJcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSByZXN1bHQubGVuZ3RoXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlZCBhbGwgJHtkZWxldGVkQ291bnR9IGV2YWx1YXRpb25zYClcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJOZW9uOiBFcnJvciBkZWxldGluZyBhbGwgZXZhbHVhdGlvbnM6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogQ2FsY3VsYXRlIGF2ZXJhZ2Ugd2VpZ2h0cyAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZVdlaWdodHMoZXZhbHVhdGlvbnM6IEFIUEV2YWx1YXRpb25bXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xyXG4gIGlmIChldmFsdWF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiB7fVxyXG5cclxuICBjb25zdCBhbGxXZWlnaHRzID0gZXZhbHVhdGlvbnMubWFwKChldmFsdWF0aW9uKSA9PiBldmFsdWF0aW9uLmdsb2JhbF93ZWlnaHRzKVxyXG4gIGNvbnN0IGNyaXRlcmlhSWRzID0gT2JqZWN0LmtleXMoYWxsV2VpZ2h0c1swXSB8fCB7fSlcclxuICBjb25zdCBhdmVyYWdlV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XHJcblxyXG4gIGNyaXRlcmlhSWRzLmZvckVhY2goKGNyaXRlcmlhSWQpID0+IHtcclxuICAgIGNvbnN0IHdlaWdodHMgPSBhbGxXZWlnaHRzLm1hcCgodykgPT4gd1tjcml0ZXJpYUlkXSB8fCAwKVxyXG4gICAgYXZlcmFnZVdlaWdodHNbY3JpdGVyaWFJZF0gPSB3ZWlnaHRzLnJlZHVjZSgoc3VtLCB3ZWlnaHQpID0+IHN1bSArIHdlaWdodCwgMCkgLyB3ZWlnaHRzLmxlbmd0aFxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBhdmVyYWdlV2VpZ2h0c1xyXG59XHJcblxyXG4vKiBTdG9yYWdlIHN0YXRzICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHMoKSB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsRXZhbHVhdGlvbnM6IG1lbS5sZW5ndGgsXHJcbiAgICAgIGxhc3RVcGRhdGVkOlxyXG4gICAgICAgIG1lbS5sZW5ndGggPiAwXHJcbiAgICAgICAgICA/IG1lbS5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLnVwZGF0ZWRfYXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEudXBkYXRlZF9hdCkuZ2V0VGltZSgpKVswXS51cGRhdGVkX2F0XHJcbiAgICAgICAgICA6IG51bGwsXHJcbiAgICAgIHN0b3JhZ2U6IFwiaW4tbWVtb3J5XCIsXHJcbiAgICAgIGNvbm5lY3Rpb25FcnJvcixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsIWBcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIENPVU5UKCopIGFzIHRvdGFsX2V2YWx1YXRpb25zLFxyXG4gICAgICAgIE1BWCh1cGRhdGVkX2F0KSBhcyBsYXN0X3VwZGF0ZWRcclxuICAgICAgRlJPTSBhaHBfZXZhbHVhdGlvbnNcclxuICAgIGBcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEV2YWx1YXRpb25zOiBOdW1iZXIocmVzdWx0WzBdLnRvdGFsX2V2YWx1YXRpb25zKSxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IHJlc3VsdFswXS5sYXN0X3VwZGF0ZWQsXHJcbiAgICAgIHN0b3JhZ2U6IFwibmVvblwiLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3I6IG51bGwsXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCLEsHN0YXRpc3RpayBhbG1hIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxFdmFsdWF0aW9uczogMCxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IG51bGwsXHJcbiAgICAgIHN0b3JhZ2U6IFwiZXJyb3JcIixcclxuICAgICAgY29ubmVjdGlvbkVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogRGF0YWJhc2UgY29ubmVjdGlvbiBjaGVjayAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEYXRhYmFzZUNvbm5lY3Rpb24oKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBEYXRhYmFzZSBjb25uZWN0aW9uIGNoZWNrIGZhaWxlZDogJHtjb25uZWN0aW9uRXJyb3J9YClcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRQcm9taXNlXHJcbiAgICAvLyBUZXN0IHRoZSBjb25uZWN0aW9uIHdpdGggYSBzaW1wbGUgcXVlcnlcclxuICAgIGF3YWl0IHNxbCFgU0VMRUNUIDEgYXMgdGVzdGBcclxuICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2UgY29ubmVjdGlvbiB0ZXN0IHN1Y2Nlc3NmdWxcIilcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogU2ltcGxlIGNvbm5lY3Rpb24gc3RhdHVzIGNoZWNrICh3aXRob3V0IGFjdHVhbCBxdWVyeSkgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YWJhc2VSZWFkeSgpOiBib29sZWFuIHtcclxuICByZXR1cm4gbmVvblJlYWR5ICYmIHNxbCAhPT0gbnVsbFxyXG59XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuLyogIFV0aWxpdHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5mdW5jdGlvbiBwYXJzZVJvdyhyb3c6IGFueSk6IEFIUEV2YWx1YXRpb24ge1xyXG4gIGNvbnN0IHNhZmVKc29uUGFyc2UgPSAodmFsdWU6IGFueSwgZmFsbGJhY2s6IGFueSA9IHt9KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZSAvLyBBbHJlYWR5IHBhcnNlZFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSlNPTiBwYXJzZSBlcnJvciBmb3IgdmFsdWU6XCIsIHZhbHVlLCBlcnJvcilcclxuICAgICAgICByZXR1cm4gZmFsbGJhY2tcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiByb3cuaWQsXHJcbiAgICB1c2VyX25hbWU6IHJvdy51c2VyX25hbWUsXHJcbiAgICBjcml0ZXJpYV93ZWlnaHRzOiBzYWZlSnNvblBhcnNlKHJvdy5jcml0ZXJpYV93ZWlnaHRzLCB7fSksXHJcbiAgICBnbG9iYWxfd2VpZ2h0czogc2FmZUpzb25QYXJzZShyb3cuZ2xvYmFsX3dlaWdodHMsIHt9KSxcclxuICAgIGNvbnNpc3RlbmN5X3Jlc3VsdHM6IHNhZmVKc29uUGFyc2Uocm93LmNvbnNpc3RlbmN5X3Jlc3VsdHMsIHt9KSxcclxuICAgIGhpZXJhcmNoeV9kYXRhOiBzYWZlSnNvblBhcnNlKHJvdy5oaWVyYXJjaHlfZGF0YSwge30pLFxyXG4gICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXHJcbiAgICB1cGRhdGVkX2F0OiByb3cudXBkYXRlZF9hdCxcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcclxuICByZXR1cm4gRGF0ZS5ub3coKS50b1N0cmluZygzNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKVxyXG59XHJcblxyXG4vLyBFeHBvcnQgY29ubmVjdGlvbiBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cygpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbmVvblJlYWR5LFxyXG4gICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgaGFzRW52aXJvbm1lbnRVcmw6ICEhcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMLFxyXG4gICAgdXJsVmFsaWQ6IHByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTCA/IHZhbGlkYXRlRGF0YWJhc2VVcmwocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSA6IGZhbHNlLFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsibmVvbiIsInNxbCIsIm5lb25SZWFkeSIsImNvbm5lY3Rpb25FcnJvciIsInZhbGlkYXRlRGF0YWJhc2VVcmwiLCJ1cmwiLCJzdGFydHNXaXRoIiwidXJsT2JqIiwiVVJMIiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInByb2Nlc3MiLCJlbnYiLCJEQVRBQkFTRV9VUkwiLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJ3YXJuIiwiZSIsImVycm9yIiwibWVzc2FnZSIsImNyZWF0ZVRhYmxlcyIsImluaXRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtZW0iLCJtZW1GaW5kQnlVc2VyIiwidSIsImZpbmQiLCJ1c2VyX25hbWUiLCJtZW1TYXZlIiwicm93IiwiaSIsImZpbmRJbmRleCIsInB1c2giLCJpbml0aWFsaXplRGF0YWJhc2UiLCJzYXZlQUhQRXZhbHVhdGlvbiIsInVzZXJOYW1lIiwiY3JpdGVyaWFXZWlnaHRzIiwiZ2xvYmFsV2VpZ2h0cyIsImNvbnNpc3RlbmN5UmVzdWx0cyIsImhpZXJhcmNoeURhdGEiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJpZCIsImdlbmVyYXRlSWQiLCJjcml0ZXJpYV93ZWlnaHRzIiwiZ2xvYmFsX3dlaWdodHMiLCJjb25zaXN0ZW5jeV9yZXN1bHRzIiwiaGllcmFyY2h5X2RhdGEiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImV4aXN0aW5nIiwibGVuZ3RoIiwicmVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlUm93Iiwic3RhY2siLCJnZXRBbGxBSFBFdmFsdWF0aW9ucyIsIm1hcCIsImdldEFIUEV2YWx1YXRpb25CeVVzZXIiLCJkZWxldGVBSFBFdmFsdWF0aW9uIiwic3BsaWNlIiwicmVzdWx0IiwiZGVsZXRlZCIsImRlbGV0ZU11bHRpcGxlQUhQRXZhbHVhdGlvbnMiLCJldmFsdWF0aW9uSWRzIiwiZGVsZXRlZENvdW50IiwiZm9yRWFjaCIsInIiLCJkZWxldGVBbGxBSFBFdmFsdWF0aW9ucyIsInByZXZpb3VzQ291bnQiLCJjYWxjdWxhdGVBdmVyYWdlV2VpZ2h0cyIsImV2YWx1YXRpb25zIiwiYWxsV2VpZ2h0cyIsImV2YWx1YXRpb24iLCJjcml0ZXJpYUlkcyIsIk9iamVjdCIsImtleXMiLCJhdmVyYWdlV2VpZ2h0cyIsImNyaXRlcmlhSWQiLCJ3ZWlnaHRzIiwidyIsInJlZHVjZSIsInN1bSIsIndlaWdodCIsImdldFN0b3JhZ2VTdGF0cyIsInRvdGFsRXZhbHVhdGlvbnMiLCJsYXN0VXBkYXRlZCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJzdG9yYWdlIiwiTnVtYmVyIiwidG90YWxfZXZhbHVhdGlvbnMiLCJsYXN0X3VwZGF0ZWQiLCJjaGVja0RhdGFiYXNlQ29ubmVjdGlvbiIsImlzRGF0YWJhc2VSZWFkeSIsInNhZmVKc29uUGFyc2UiLCJ2YWx1ZSIsImZhbGxiYWNrIiwicGFyc2UiLCJ0b1N0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJoYXNFbnZpcm9ubWVudFVybCIsInVybFZhbGlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/neon-db.ts\n"));

/***/ })

});