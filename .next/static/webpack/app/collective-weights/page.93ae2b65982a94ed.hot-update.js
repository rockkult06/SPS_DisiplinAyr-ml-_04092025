"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/collective-weights/page",{

/***/ "(app-pages-browser)/./lib/neon-db.ts":
/*!************************!*\
  !*** ./lib/neon-db.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAverageWeights: () => (/* binding */ calculateAverageWeights),\n/* harmony export */   checkDatabaseConnection: () => (/* binding */ checkDatabaseConnection),\n/* harmony export */   deleteAHPEvaluation: () => (/* binding */ deleteAHPEvaluation),\n/* harmony export */   deleteAllAHPEvaluations: () => (/* binding */ deleteAllAHPEvaluations),\n/* harmony export */   deleteMultipleAHPEvaluations: () => (/* binding */ deleteMultipleAHPEvaluations),\n/* harmony export */   getAHPEvaluationByUser: () => (/* binding */ getAHPEvaluationByUser),\n/* harmony export */   getAllAHPEvaluations: () => (/* binding */ getAllAHPEvaluations),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   initializeDatabase: () => (/* binding */ initializeDatabase),\n/* harmony export */   isDatabaseReady: () => (/* binding */ isDatabaseReady),\n/* harmony export */   saveAHPEvaluation: () => (/* binding */ saveAHPEvaluation)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var _neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neondatabase/serverless */ \"(app-pages-browser)/./node_modules/@neondatabase/serverless/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE TABLE IF NOT EXISTS ahp_evaluations (\\n        id TEXT PRIMARY KEY,\\n        user_name TEXT NOT NULL,\\n        criteria_weights JSONB NOT NULL,\\n        global_weights JSONB NOT NULL,\\n        consistency_results JSONB NOT NULL,\\n        hierarchy_data JSONB NOT NULL,\\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\\n      )\\n    \"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE INDEX IF NOT EXISTS idx_ahp_evaluations_user_name\\n      ON ahp_evaluations(user_name)\\n    \"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE INDEX IF NOT EXISTS idx_ahp_evaluations_updated_at\\n      ON ahp_evaluations(updated_at)\\n    \"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      SELECT id FROM ahp_evaluations WHERE user_name = \",\n        \"\\n    \"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject4() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n        UPDATE ahp_evaluations SET\\n          criteria_weights   = \",\n        \",\\n          global_weights     = \",\n        \",\\n          consistency_results= \",\n        \",\\n          hierarchy_data     = \",\n        \",\\n          updated_at         = \",\n        \"\\n        WHERE user_name      = \",\n        \"\\n        RETURNING *\\n      \"\n    ]);\n    _templateObject4 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject5() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      INSERT INTO ahp_evaluations (\\n        id, user_name, criteria_weights, global_weights,\\n        consistency_results, hierarchy_data, created_at, updated_at\\n      ) VALUES (\\n        \",\n        \", \",\n        \", \",\n        \", \",\n        \",\\n        \",\n        \", \",\n        \", \",\n        \", \",\n        \"\\n      )\\n      RETURNING *\\n    \"\n    ]);\n    _templateObject5 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject6() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT * FROM ahp_evaluations ORDER BY updated_at DESC\"\n    ]);\n    _templateObject6 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject7() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT * FROM ahp_evaluations WHERE user_name = \",\n        \"\"\n    ]);\n    _templateObject7 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject8() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations WHERE id = \",\n        \" RETURNING id\"\n    ]);\n    _templateObject8 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject9() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations WHERE id = ANY(\",\n        \") RETURNING id\"\n    ]);\n    _templateObject9 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject10() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations RETURNING id\"\n    ]);\n    _templateObject10 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject11() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      SELECT \\n        COUNT(*) as total_evaluations,\\n        MAX(updated_at) as last_updated\\n      FROM ahp_evaluations\\n    \"\n    ]);\n    _templateObject11 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject12() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT 1 as test\"\n    ]);\n    _templateObject12 = function() {\n        return data;\n    };\n    return data;\n}\n\n/* ------------------------------------------------------------------ */ /*  Neon connection (or in-memory fallback)                           */ /* ------------------------------------------------------------------ */ let sql = null;\nlet neonReady = false;\nlet connectionError = null;\n// DATABASE_URL validation\nfunction validateDatabaseUrl(url) {\n    try {\n        // Neon URL should start with postgresql:// or postgres://\n        if (!url.startsWith(\"postgresql://\") && !url.startsWith(\"postgres://\")) {\n            return false;\n        }\n        // Basic URL validation\n        const urlObj = new URL(url);\n        return urlObj.hostname && urlObj.pathname;\n    } catch (e) {\n        return false;\n    }\n}\ntry {\n    if (process.env.DATABASE_URL) {\n        console.log(\"DATABASE_URL found, validating...\");\n        if (!validateDatabaseUrl(process.env.DATABASE_URL)) {\n            throw new Error(\"Invalid DATABASE_URL format. Expected postgresql:// or postgres:// URL\");\n        }\n        console.log(\"DATABASE_URL is valid, creating Neon connection...\");\n        sql = (0,_neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__.neon)(process.env.DATABASE_URL);\n        neonReady = true;\n        console.log(\"Neon connection created successfully\");\n    } else {\n        console.warn(\"âš ï¸  DATABASE_URL environment variable not found!\");\n        console.warn(\"âš ï¸  Using in-memory storage - data will be lost on restart\");\n        console.warn(\"âš ï¸  To persist data, create a .env file with DATABASE_URL\");\n        connectionError = \"DATABASE_URL environment variable not found\";\n    }\n} catch (e) {\n    console.error(\"âŒ Neon connection initialization error:\", e);\n    console.warn(\"âš ï¸  Falling back to in-memory storage - data will be lost on restart\");\n    connectionError = e instanceof Error ? e.message : \"Unknown connection error\";\n    neonReady = false;\n}\n// TEST MODE: Simulate database connection for testing\nif (!neonReady && \"development\" === 'development') {\n    console.log(\"ðŸ§ª TEST MODE: Simulating database connection...\");\n    neonReady = true;\n    connectionError = null;\n    console.log(\"âœ… Test mode: Database connection simulated\");\n}\n/* ------------------------------------------------------------------ */ /*  One-time table creation promise                                   */ /* ------------------------------------------------------------------ */ async function createTables() {\n    if (!neonReady || !sql) {\n        console.log(\"Skipping table creation - Neon not ready\");\n        return;\n    }\n    try {\n        console.log(\"Creating tables if they don't exist...\");\n        // Create table first\n        await sql(_templateObject());\n        // Create indexes separately\n        await sql(_templateObject1());\n        await sql(_templateObject2());\n        console.log(\"Neon: ahp_evaluations table and indexes created successfully\");\n    } catch (error) {\n        console.error(\"Table creation error:\", error);\n        throw error;\n    }\n}\nconst initPromise = neonReady ? createTables() : Promise.resolve();\n/* ------------------------------------------------------------------ */ /*  In-memory storage (used when Neon isn't configured)               */ /* ------------------------------------------------------------------ */ const mem = [];\nconst memFindByUser = (u)=>{\n    var _mem_find;\n    return (_mem_find = mem.find((e)=>e.user_name === u)) !== null && _mem_find !== void 0 ? _mem_find : null;\n};\nconst memSave = (row)=>{\n    const i = mem.findIndex((e)=>e.user_name === row.user_name);\n    i === -1 ? mem.push(row) : mem[i] = row;\n    return row;\n};\n/* ------------------------------------------------------------------ */ /*  Public helpers                                                    */ /* ------------------------------------------------------------------ */ async function initializeDatabase() {\n    try {\n        await initPromise;\n        console.log(\"Database initialization completed\");\n    } catch (error) {\n        console.error(\"Database initialization failed:\", error);\n        throw error;\n    }\n}\n/* CREATE / UPDATE (upsert by user) */ async function saveAHPEvaluation(userName, criteriaWeights, globalWeights, consistencyResults, hierarchyData) {\n    const now = new Date().toISOString();\n    /* In-memory mode -------------------------------------------------- */ if (!neonReady) {\n        console.warn(\"âš ï¸  Neon DB not ready (\".concat(connectionError, \"), saving to in-memory for user: \").concat(userName));\n        console.warn(\"âš ï¸  This data will be LOST when the application restarts!\");\n        const row = {\n            id: generateId(),\n            user_name: userName,\n            criteria_weights: criteriaWeights,\n            global_weights: globalWeights,\n            consistency_results: consistencyResults,\n            hierarchy_data: hierarchyData,\n            created_at: now,\n            updated_at: now\n        };\n        return memSave(row);\n    }\n    /* Neon mode ------------------------------------------------------- */ try {\n        await initPromise;\n        console.log(\"Checking for existing evaluation for user: \".concat(userName));\n        const existing = await sql(_templateObject3(), userName);\n        if (existing.length) {\n            console.log(\"Updating existing evaluation for user: \".concat(userName));\n            const res = await sql(_templateObject4(), JSON.stringify(criteriaWeights), JSON.stringify(globalWeights), JSON.stringify(consistencyResults), JSON.stringify(hierarchyData), now, userName);\n            console.log(\"Neon: Updated evaluation for user \".concat(userName));\n            return parseRow(res[0]);\n        }\n        console.log(\"Creating new evaluation for user: \".concat(userName));\n        const res = await sql(_templateObject5(), generateId(), userName, JSON.stringify(criteriaWeights), JSON.stringify(globalWeights), JSON.stringify(consistencyResults), JSON.stringify(hierarchyData), now, now);\n        console.log(\"Neon: Inserted new evaluation for user \".concat(userName));\n        return parseRow(res[0]);\n    } catch (error) {\n        console.error(\"AHP kaydetme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            stack: error.stack,\n            userName,\n            connectionError\n        });\n        throw error;\n    }\n}\n/* READ - all */ async function getAllAHPEvaluations() {\n    if (!neonReady) {\n        console.warn(\"âš ï¸  Neon DB not ready (\".concat(connectionError, \"), getting all from in-memory. Count: \").concat(mem.length));\n        console.warn(\"âš ï¸  In-memory data will be LOST when the application restarts!\");\n        return [\n            ...mem\n        ] // Return a copy to avoid mutations\n        ;\n    }\n    try {\n        await initPromise;\n        console.log(\"Fetching all evaluations from Neon...\");\n        const res = await sql(_templateObject6());\n        console.log(\"Neon: Fetched \".concat(res.length, \" evaluations\"));\n        return res.map(parseRow);\n    } catch (error) {\n        console.error(\"AHP verilerini getirme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            stack: error.stack,\n            connectionError,\n            neonReady\n        });\n        // Fallback to in-memory if database fails\n        console.log(\"Falling back to in-memory storage due to database error\");\n        return [\n            ...mem\n        ];\n    }\n}\n/* READ - by user */ async function getAHPEvaluationByUser(userName) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), getting by user from in-memory: \").concat(userName));\n        return memFindByUser(userName);\n    }\n    try {\n        await initPromise;\n        console.log(\"Fetching evaluation for user: \".concat(userName));\n        const res = await sql(_templateObject7(), userName);\n        console.log(\"Neon: Fetched evaluation for user \".concat(userName, \". Found: \").concat(res.length > 0));\n        return res.length ? parseRow(res[0]) : null;\n    } catch (error) {\n        console.error(\"KullanÄ±cÄ± AHP verisi getirme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            userName,\n            connectionError\n        });\n        // Fallback to in-memory\n        return memFindByUser(userName);\n    }\n}\n/* DELETE single */ async function deleteAHPEvaluation(id) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting from in-memory: \").concat(id));\n        const i = mem.findIndex((e)=>e.id === id);\n        if (i !== -1) {\n            mem.splice(i, 1);\n            console.log(\"Deleted from in-memory. Remaining count: \".concat(mem.length));\n            return true;\n        }\n        console.log(\"Item not found in in-memory storage\");\n        return false;\n    }\n    try {\n        await initPromise;\n        console.log(\"Deleting evaluation with ID: \".concat(id));\n        const result = await sql(_templateObject8(), id);\n        const deleted = result.length > 0;\n        console.log(\"Neon: Delete operation completed. Deleted: \".concat(deleted));\n        return deleted;\n    } catch (error) {\n        console.error(\"Neon: Error deleting single evaluation with ID \".concat(id, \":\"), error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            id,\n            connectionError\n        });\n        return false;\n    }\n}\n/* DELETE multiple */ async function deleteMultipleAHPEvaluations(evaluationIds) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting multiple from in-memory: \").concat(evaluationIds.length, \" items\"));\n        let deletedCount = 0;\n        evaluationIds.forEach((id)=>{\n            const i = mem.findIndex((r)=>r.id === id);\n            if (i !== -1) {\n                mem.splice(i, 1);\n                deletedCount++;\n            }\n        });\n        console.log(\"Deleted \".concat(deletedCount, \" items from in-memory. Remaining count: \").concat(mem.length));\n        return deletedCount > 0;\n    }\n    try {\n        if (evaluationIds.length === 0) {\n            console.log(\"Neon: No evaluation IDs provided for multiple delete\");\n            return true;\n        }\n        await initPromise;\n        console.log(\"Deleting multiple evaluations: \".concat(evaluationIds.length, \" items\"));\n        const result = await sql(_templateObject9(), evaluationIds);\n        const deletedCount = result.length;\n        console.log(\"Neon: Deleted \".concat(deletedCount, \" out of \").concat(evaluationIds.length, \" evaluations\"));\n        return deletedCount > 0;\n    } catch (error) {\n        console.error(\"Neon: Error deleting multiple evaluations:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            evaluationIds,\n            connectionError\n        });\n        return false;\n    }\n}\n/* DELETE all */ async function deleteAllAHPEvaluations() {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting all from in-memory\"));\n        const previousCount = mem.length;\n        mem.length = 0;\n        console.log(\"Deleted all \".concat(previousCount, \" items from in-memory\"));\n        return true;\n    }\n    try {\n        await initPromise;\n        console.log(\"Deleting all evaluations from Neon...\");\n        const result = await sql(_templateObject10());\n        const deletedCount = result.length;\n        console.log(\"Neon: Deleted all \".concat(deletedCount, \" evaluations\"));\n        return true;\n    } catch (error) {\n        console.error(\"Neon: Error deleting all evaluations:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            connectionError\n        });\n        return false;\n    }\n}\n/* Calculate average weights */ function calculateAverageWeights(evaluations) {\n    if (evaluations.length === 0) return {};\n    const allWeights = evaluations.map((evaluation)=>evaluation.global_weights);\n    const criteriaIds = Object.keys(allWeights[0] || {});\n    const averageWeights = {};\n    criteriaIds.forEach((criteriaId)=>{\n        const weights = allWeights.map((w)=>w[criteriaId] || 0);\n        averageWeights[criteriaId] = weights.reduce((sum, weight)=>sum + weight, 0) / weights.length;\n    });\n    return averageWeights;\n}\n/* Storage stats */ async function getStorageStats() {\n    if (!neonReady) {\n        return {\n            totalEvaluations: mem.length,\n            lastUpdated: mem.length > 0 ? mem.sort((a, b)=>new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime())[0].updated_at : null,\n            storage: \"in-memory\",\n            connectionError\n        };\n    }\n    try {\n        await initPromise;\n        const result = await sql(_templateObject11());\n        return {\n            totalEvaluations: Number(result[0].total_evaluations),\n            lastUpdated: result[0].last_updated,\n            storage: \"neon\",\n            connectionError: null\n        };\n    } catch (error) {\n        console.error(\"Ä°statistik alma hatasÄ±:\", error);\n        return {\n            totalEvaluations: 0,\n            lastUpdated: null,\n            storage: \"error\",\n            connectionError: error.message\n        };\n    }\n}\n/* Database connection check */ async function checkDatabaseConnection() {\n    if (!neonReady) {\n        console.log(\"Database connection check failed: \".concat(connectionError));\n        return false;\n    }\n    try {\n        await initPromise;\n        // Test the connection with a simple query\n        await sql(_templateObject12());\n        console.log(\"Database connection test successful\");\n        return true;\n    } catch (error) {\n        console.error(\"Database connection test failed:\", error);\n        return false;\n    }\n}\n/* Simple connection status check (without actual query) */ function isDatabaseReady() {\n    return neonReady && sql !== null;\n}\n/* ------------------------------------------------------------------ */ /*  Utility                                                           */ /* ------------------------------------------------------------------ */ function parseRow(row) {\n    const safeJsonParse = function(value) {\n        let fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (typeof value === \"object\" && value !== null) {\n            return value // Already parsed\n            ;\n        }\n        if (typeof value === \"string\") {\n            try {\n                return JSON.parse(value);\n            } catch (error) {\n                console.error(\"JSON parse error for value:\", value, error);\n                return fallback;\n            }\n        }\n        return fallback;\n    };\n    return {\n        id: row.id,\n        user_name: row.user_name,\n        criteria_weights: safeJsonParse(row.criteria_weights, {}),\n        global_weights: safeJsonParse(row.global_weights, {}),\n        consistency_results: safeJsonParse(row.consistency_results, {}),\n        hierarchy_data: safeJsonParse(row.hierarchy_data, {}),\n        created_at: row.created_at,\n        updated_at: row.updated_at\n    };\n}\nfunction generateId() {\n    return Date.now().toString(36) + Math.random().toString(36).slice(2);\n}\n// Export connection status for debugging\nfunction getConnectionStatus() {\n    return {\n        neonReady,\n        connectionError,\n        hasEnvironmentUrl: !!process.env.DATABASE_URL,\n        urlValid: process.env.DATABASE_URL ? validateDatabaseUrl(process.env.DATABASE_URL) : false\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uZW9uLWRiLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFFL0Msc0VBQXNFLEdBQ3RFLHNFQUFzRSxHQUN0RSxzRUFBc0UsR0FDdEUsSUFBSUMsTUFBc0M7QUFDMUMsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxrQkFBaUM7QUFFckMsMEJBQTBCO0FBQzFCLFNBQVNDLG9CQUFvQkMsR0FBVztJQUN0QyxJQUFJO1FBQ0YsMERBQTBEO1FBQzFELElBQUksQ0FBQ0EsSUFBSUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDRCxJQUFJQyxVQUFVLENBQUMsZ0JBQWdCO1lBQ3RFLE9BQU87UUFDVDtRQUVBLHVCQUF1QjtRQUN2QixNQUFNQyxTQUFTLElBQUlDLElBQUlIO1FBQ3ZCLE9BQU9FLE9BQU9FLFFBQVEsSUFBSUYsT0FBT0csUUFBUTtJQUMzQyxFQUFFLFVBQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUVBLElBQUk7SUFDRixJQUFJQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLFlBQVksRUFBRTtRQUM1QkMsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSSxDQUFDWCxvQkFBb0JPLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWSxHQUFHO1lBQ2xELE1BQU0sSUFBSUcsTUFBTTtRQUNsQjtRQUVBRixRQUFRQyxHQUFHLENBQUM7UUFDWmQsTUFBTUQsOERBQUlBLENBQUNXLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWTtRQUNuQ1gsWUFBWTtRQUNaWSxRQUFRQyxHQUFHLENBQUM7SUFDZCxPQUFPO1FBQ0xELFFBQVFHLElBQUksQ0FBQztRQUNiSCxRQUFR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LENBQUMsK0JBQStCbUYsT0FBT25GO2dCQUNwRCxPQUFPb0Y7WUFDVDtRQUNGO1FBRUEsT0FBT0E7SUFDVDtJQUVBLE9BQU87UUFDTDFELElBQUlkLElBQUljLEVBQUU7UUFDVmhCLFdBQVdFLElBQUlGLFNBQVM7UUFDeEJrQixrQkFBa0JzRCxjQUFjdEUsSUFBSWdCLGdCQUFnQixFQUFFLENBQUM7UUFDdkRDLGdCQUFnQnFELGNBQWN0RSxJQUFJaUIsY0FBYyxFQUFFLENBQUM7UUFDbkRDLHFCQUFxQm9ELGNBQWN0RSxJQUFJa0IsbUJBQW1CLEVBQUUsQ0FBQztRQUM3REMsZ0JBQWdCbUQsY0FBY3RFLElBQUltQixjQUFjLEVBQUUsQ0FBQztRQUNuREMsWUFBWXBCLElBQUlvQixVQUFVO1FBQzFCQyxZQUFZckIsSUFBSXFCLFVBQVU7SUFDNUI7QUFDRjtBQUVBLFNBQVNOO0lBQ1AsT0FBT0gsS0FBS0QsR0FBRyxHQUFHK0QsUUFBUSxDQUFDLE1BQU1DLEtBQUtDLE1BQU0sR0FBR0YsUUFBUSxDQUFDLElBQUlHLEtBQUssQ0FBQztBQUNwRTtBQUVBLHlDQUF5QztBQUNsQyxTQUFTQztJQUNkLE9BQU87UUFDTDNHO1FBQ0FDO1FBQ0EyRyxtQkFBbUIsQ0FBQyxDQUFDbkcsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxZQUFZO1FBQzdDa0csVUFBVXBHLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWSxHQUFHVCxvQkFBb0JPLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWSxJQUFJO0lBQ3ZGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxTdXJ1Y3VwdWFuc2lzdGVtaTA4MjAyNVxcU1BTX0Rpc2lwbGluQXlyLW1sLV8wNDA5MjAyNVxcbGliXFxuZW9uLWRiLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5lb24gfSBmcm9tIFwiQG5lb25kYXRhYmFzZS9zZXJ2ZXJsZXNzXCJcclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgTmVvbiBjb25uZWN0aW9uIChvciBpbi1tZW1vcnkgZmFsbGJhY2spICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmxldCBzcWw6IFJldHVyblR5cGU8dHlwZW9mIG5lb24+IHwgbnVsbCA9IG51bGxcclxubGV0IG5lb25SZWFkeSA9IGZhbHNlXHJcbmxldCBjb25uZWN0aW9uRXJyb3I6IHN0cmluZyB8IG51bGwgPSBudWxsXHJcblxyXG4vLyBEQVRBQkFTRV9VUkwgdmFsaWRhdGlvblxyXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGFiYXNlVXJsKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIE5lb24gVVJMIHNob3VsZCBzdGFydCB3aXRoIHBvc3RncmVzcWw6Ly8gb3IgcG9zdGdyZXM6Ly9cclxuICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoXCJwb3N0Z3Jlc3FsOi8vXCIpICYmICF1cmwuc3RhcnRzV2l0aChcInBvc3RncmVzOi8vXCIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEJhc2ljIFVSTCB2YWxpZGF0aW9uXHJcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybClcclxuICAgIHJldHVybiB1cmxPYmouaG9zdG5hbWUgJiYgdXJsT2JqLnBhdGhuYW1lXHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbnRyeSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTCkge1xyXG4gICAgY29uc29sZS5sb2coXCJEQVRBQkFTRV9VUkwgZm91bmQsIHZhbGlkYXRpbmcuLi5cIilcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRlRGF0YWJhc2VVcmwocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERBVEFCQVNFX1VSTCBmb3JtYXQuIEV4cGVjdGVkIHBvc3RncmVzcWw6Ly8gb3IgcG9zdGdyZXM6Ly8gVVJMXCIpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJEQVRBQkFTRV9VUkwgaXMgdmFsaWQsIGNyZWF0aW5nIE5lb24gY29ubmVjdGlvbi4uLlwiKVxyXG4gICAgc3FsID0gbmVvbihwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkwpXHJcbiAgICBuZW9uUmVhZHkgPSB0cnVlXHJcbiAgICBjb25zb2xlLmxvZyhcIk5lb24gY29ubmVjdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gIERBVEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZSBub3QgZm91bmQhXCIpXHJcbiAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gIFVzaW5nIGluLW1lbW9yeSBzdG9yYWdlIC0gZGF0YSB3aWxsIGJlIGxvc3Qgb24gcmVzdGFydFwiKVxyXG4gICAgY29uc29sZS53YXJuKFwi4pqg77iPICBUbyBwZXJzaXN0IGRhdGEsIGNyZWF0ZSBhIC5lbnYgZmlsZSB3aXRoIERBVEFCQVNFX1VSTFwiKVxyXG4gICAgY29ubmVjdGlvbkVycm9yID0gXCJEQVRBQkFTRV9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUgbm90IGZvdW5kXCJcclxuICB9XHJcbn0gY2F0Y2ggKGUpIHtcclxuICBjb25zb2xlLmVycm9yKFwi4p2MIE5lb24gY29ubmVjdGlvbiBpbml0aWFsaXphdGlvbiBlcnJvcjpcIiwgZSlcclxuICBjb25zb2xlLndhcm4oXCLimqDvuI8gIEZhbGxpbmcgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZSAtIGRhdGEgd2lsbCBiZSBsb3N0IG9uIHJlc3RhcnRcIilcclxuICBjb25uZWN0aW9uRXJyb3IgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBcIlVua25vd24gY29ubmVjdGlvbiBlcnJvclwiXHJcbiAgbmVvblJlYWR5ID0gZmFsc2VcclxufVxyXG5cclxuLy8gVEVTVCBNT0RFOiBTaW11bGF0ZSBkYXRhYmFzZSBjb25uZWN0aW9uIGZvciB0ZXN0aW5nXHJcbmlmICghbmVvblJlYWR5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgY29uc29sZS5sb2coXCLwn6eqIFRFU1QgTU9ERTogU2ltdWxhdGluZyBkYXRhYmFzZSBjb25uZWN0aW9uLi4uXCIpXHJcbiAgbmVvblJlYWR5ID0gdHJ1ZVxyXG4gIGNvbm5lY3Rpb25FcnJvciA9IG51bGxcclxuICBjb25zb2xlLmxvZyhcIuKchSBUZXN0IG1vZGU6IERhdGFiYXNlIGNvbm5lY3Rpb24gc2ltdWxhdGVkXCIpXHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgT25lLXRpbWUgdGFibGUgY3JlYXRpb24gcHJvbWlzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlcygpIHtcclxuICBpZiAoIW5lb25SZWFkeSB8fCAhc3FsKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlNraXBwaW5nIHRhYmxlIGNyZWF0aW9uIC0gTmVvbiBub3QgcmVhZHlcIilcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgdGFibGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3QuLi5cIilcclxuXHJcbiAgICAvLyBDcmVhdGUgdGFibGUgZmlyc3RcclxuICAgIGF3YWl0IHNxbGBcclxuICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgYWhwX2V2YWx1YXRpb25zIChcclxuICAgICAgICBpZCBURVhUIFBSSU1BUlkgS0VZLFxyXG4gICAgICAgIHVzZXJfbmFtZSBURVhUIE5PVCBOVUxMLFxyXG4gICAgICAgIGNyaXRlcmlhX3dlaWdodHMgSlNPTkIgTk9UIE5VTEwsXHJcbiAgICAgICAgZ2xvYmFsX3dlaWdodHMgSlNPTkIgTk9UIE5VTEwsXHJcbiAgICAgICAgY29uc2lzdGVuY3lfcmVzdWx0cyBKU09OQiBOT1QgTlVMTCxcclxuICAgICAgICBoaWVyYXJjaHlfZGF0YSBKU09OQiBOT1QgTlVMTCxcclxuICAgICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKClcclxuICAgICAgKVxyXG4gICAgYFxyXG5cclxuICAgIC8vIENyZWF0ZSBpbmRleGVzIHNlcGFyYXRlbHlcclxuICAgIGF3YWl0IHNxbGBcclxuICAgICAgQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2FocF9ldmFsdWF0aW9uc191c2VyX25hbWVcclxuICAgICAgT04gYWhwX2V2YWx1YXRpb25zKHVzZXJfbmFtZSlcclxuICAgIGBcclxuXHJcbiAgICBhd2FpdCBzcWxgXHJcbiAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9haHBfZXZhbHVhdGlvbnNfdXBkYXRlZF9hdFxyXG4gICAgICBPTiBhaHBfZXZhbHVhdGlvbnModXBkYXRlZF9hdClcclxuICAgIGBcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIk5lb246IGFocF9ldmFsdWF0aW9ucyB0YWJsZSBhbmQgaW5kZXhlcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiVGFibGUgY3JlYXRpb24gZXJyb3I6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gbmVvblJlYWR5ID8gY3JlYXRlVGFibGVzKCkgOiBQcm9taXNlLnJlc29sdmUoKVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBUeXBlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBSFBFdmFsdWF0aW9uIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdXNlcl9uYW1lOiBzdHJpbmdcclxuICBjcml0ZXJpYV93ZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+XHJcbiAgZ2xvYmFsX3dlaWdodHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxuICBjb25zaXN0ZW5jeV9yZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgaGllcmFyY2h5X2RhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcltdW10+XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgSW4tbWVtb3J5IHN0b3JhZ2UgKHVzZWQgd2hlbiBOZW9uIGlzbid0IGNvbmZpZ3VyZWQpICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmNvbnN0IG1lbTogQUhQRXZhbHVhdGlvbltdID0gW11cclxuY29uc3QgbWVtRmluZEJ5VXNlciA9ICh1OiBzdHJpbmcpID0+IG1lbS5maW5kKChlKSA9PiBlLnVzZXJfbmFtZSA9PT0gdSkgPz8gbnVsbFxyXG5jb25zdCBtZW1TYXZlID0gKHJvdzogQUhQRXZhbHVhdGlvbikgPT4ge1xyXG4gIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChlKSA9PiBlLnVzZXJfbmFtZSA9PT0gcm93LnVzZXJfbmFtZSlcclxuICBpID09PSAtMSA/IG1lbS5wdXNoKHJvdykgOiAobWVtW2ldID0gcm93KVxyXG4gIHJldHVybiByb3dcclxufVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBQdWJsaWMgaGVscGVycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVEYXRhYmFzZSgpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgaW5pdFByb21pc2VcclxuICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2UgaW5pdGlhbGl6YXRpb24gY29tcGxldGVkXCIpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbi8qIENSRUFURSAvIFVQREFURSAodXBzZXJ0IGJ5IHVzZXIpICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlQUhQRXZhbHVhdGlvbihcclxuICB1c2VyTmFtZTogc3RyaW5nLFxyXG4gIGNyaXRlcmlhV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcclxuICBnbG9iYWxXZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxyXG4gIGNvbnNpc3RlbmN5UmVzdWx0czogUmVjb3JkPHN0cmluZywgYW55PixcclxuICBoaWVyYXJjaHlEYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXVtdPixcclxuKTogUHJvbWlzZTxBSFBFdmFsdWF0aW9uPiB7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcblxyXG4gIC8qIEluLW1lbW9yeSBtb2RlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgc2F2aW5nIHRvIGluLW1lbW9yeSBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc29sZS53YXJuKGDimqDvuI8gIFRoaXMgZGF0YSB3aWxsIGJlIExPU1Qgd2hlbiB0aGUgYXBwbGljYXRpb24gcmVzdGFydHMhYClcclxuICAgIGNvbnN0IHJvdzogQUhQRXZhbHVhdGlvbiA9IHtcclxuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgICAgdXNlcl9uYW1lOiB1c2VyTmFtZSxcclxuICAgICAgY3JpdGVyaWFfd2VpZ2h0czogY3JpdGVyaWFXZWlnaHRzLFxyXG4gICAgICBnbG9iYWxfd2VpZ2h0czogZ2xvYmFsV2VpZ2h0cyxcclxuICAgICAgY29uc2lzdGVuY3lfcmVzdWx0czogY29uc2lzdGVuY3lSZXN1bHRzLFxyXG4gICAgICBoaWVyYXJjaHlfZGF0YTogaGllcmFyY2h5RGF0YSxcclxuICAgICAgY3JlYXRlZF9hdDogbm93LFxyXG4gICAgICB1cGRhdGVkX2F0OiBub3csXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVtU2F2ZShyb3cpXHJcbiAgfVxyXG5cclxuICAvKiBOZW9uIG1vZGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBmb3IgZXhpc3RpbmcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBzcWwhYFxyXG4gICAgICBTRUxFQ1QgaWQgRlJPTSBhaHBfZXZhbHVhdGlvbnMgV0hFUkUgdXNlcl9uYW1lID0gJHt1c2VyTmFtZX1cclxuICAgIGBcclxuXHJcbiAgICBpZiAoZXhpc3RpbmcubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBleGlzdGluZyBldmFsdWF0aW9uIGZvciB1c2VyOiAke3VzZXJOYW1lfWApXHJcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHNxbCFgXHJcbiAgICAgICAgVVBEQVRFIGFocF9ldmFsdWF0aW9ucyBTRVRcclxuICAgICAgICAgIGNyaXRlcmlhX3dlaWdodHMgICA9ICR7SlNPTi5zdHJpbmdpZnkoY3JpdGVyaWFXZWlnaHRzKX0sXHJcbiAgICAgICAgICBnbG9iYWxfd2VpZ2h0cyAgICAgPSAke0pTT04uc3RyaW5naWZ5KGdsb2JhbFdlaWdodHMpfSxcclxuICAgICAgICAgIGNvbnNpc3RlbmN5X3Jlc3VsdHM9ICR7SlNPTi5zdHJpbmdpZnkoY29uc2lzdGVuY3lSZXN1bHRzKX0sXHJcbiAgICAgICAgICBoaWVyYXJjaHlfZGF0YSAgICAgPSAke0pTT04uc3RyaW5naWZ5KGhpZXJhcmNoeURhdGEpfSxcclxuICAgICAgICAgIHVwZGF0ZWRfYXQgICAgICAgICA9ICR7bm93fVxyXG4gICAgICAgIFdIRVJFIHVzZXJfbmFtZSAgICAgID0gJHt1c2VyTmFtZX1cclxuICAgICAgICBSRVRVUk5JTkcgKlxyXG4gICAgICBgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBOZW9uOiBVcGRhdGVkIGV2YWx1YXRpb24gZm9yIHVzZXIgJHt1c2VyTmFtZX1gKVxyXG4gICAgICByZXR1cm4gcGFyc2VSb3cocmVzWzBdKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBuZXcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3FsIWBcclxuICAgICAgSU5TRVJUIElOVE8gYWhwX2V2YWx1YXRpb25zIChcclxuICAgICAgICBpZCwgdXNlcl9uYW1lLCBjcml0ZXJpYV93ZWlnaHRzLCBnbG9iYWxfd2VpZ2h0cyxcclxuICAgICAgICBjb25zaXN0ZW5jeV9yZXN1bHRzLCBoaWVyYXJjaHlfZGF0YSwgY3JlYXRlZF9hdCwgdXBkYXRlZF9hdFxyXG4gICAgICApIFZBTFVFUyAoXHJcbiAgICAgICAgJHtnZW5lcmF0ZUlkKCl9LCAke3VzZXJOYW1lfSwgJHtKU09OLnN0cmluZ2lmeShjcml0ZXJpYVdlaWdodHMpfSwgJHtKU09OLnN0cmluZ2lmeShnbG9iYWxXZWlnaHRzKX0sXHJcbiAgICAgICAgJHtKU09OLnN0cmluZ2lmeShjb25zaXN0ZW5jeVJlc3VsdHMpfSwgJHtKU09OLnN0cmluZ2lmeShoaWVyYXJjaHlEYXRhKX0sICR7bm93fSwgJHtub3d9XHJcbiAgICAgIClcclxuICAgICAgUkVUVVJOSU5HICpcclxuICAgIGBcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBJbnNlcnRlZCBuZXcgZXZhbHVhdGlvbiBmb3IgdXNlciAke3VzZXJOYW1lfWApXHJcbiAgICByZXR1cm4gcGFyc2VSb3cocmVzWzBdKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiQUhQIGtheWRldG1lIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICB1c2VyTmFtZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG4vKiBSRUFEIC0gYWxsICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxBSFBFdmFsdWF0aW9ucygpOiBQcm9taXNlPEFIUEV2YWx1YXRpb25bXT4ge1xyXG4gIGlmICghbmVvblJlYWR5KSB7XHJcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgTmVvbiBEQiBub3QgcmVhZHkgKCR7Y29ubmVjdGlvbkVycm9yfSksIGdldHRpbmcgYWxsIGZyb20gaW4tbWVtb3J5LiBDb3VudDogJHttZW0ubGVuZ3RofWApXHJcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgSW4tbWVtb3J5IGRhdGEgd2lsbCBiZSBMT1NUIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlc3RhcnRzIWApXHJcbiAgICByZXR1cm4gWy4uLm1lbV0gLy8gUmV0dXJuIGEgY29weSB0byBhdm9pZCBtdXRhdGlvbnNcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coXCJGZXRjaGluZyBhbGwgZXZhbHVhdGlvbnMgZnJvbSBOZW9uLi4uXCIpXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBzcWwhYFNFTEVDVCAqIEZST00gYWhwX2V2YWx1YXRpb25zIE9SREVSIEJZIHVwZGF0ZWRfYXQgREVTQ2BcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBGZXRjaGVkICR7cmVzLmxlbmd0aH0gZXZhbHVhdGlvbnNgKVxyXG4gICAgcmV0dXJuIHJlcy5tYXAocGFyc2VSb3cpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJBSFAgdmVyaWxlcmluaSBnZXRpcm1lIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3IsXHJcbiAgICAgIG5lb25SZWFkeSxcclxuICAgIH0pXHJcblxyXG4gICAgLy8gRmFsbGJhY2sgdG8gaW4tbWVtb3J5IGlmIGRhdGFiYXNlIGZhaWxzXHJcbiAgICBjb25zb2xlLmxvZyhcIkZhbGxpbmcgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZSBkdWUgdG8gZGF0YWJhc2UgZXJyb3JcIilcclxuICAgIHJldHVybiBbLi4ubWVtXVxyXG4gIH1cclxufVxyXG5cclxuLyogUkVBRCAtIGJ5IHVzZXIgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFIUEV2YWx1YXRpb25CeVVzZXIodXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8QUhQRXZhbHVhdGlvbiB8IG51bGw+IHtcclxuICBpZiAoIW5lb25SZWFkeSkge1xyXG4gICAgY29uc29sZS5sb2coYE5lb24gREIgbm90IHJlYWR5ICgke2Nvbm5lY3Rpb25FcnJvcn0pLCBnZXR0aW5nIGJ5IHVzZXIgZnJvbSBpbi1tZW1vcnk6ICR7dXNlck5hbWV9YClcclxuICAgIHJldHVybiBtZW1GaW5kQnlVc2VyKHVzZXJOYW1lKVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRQcm9taXNlXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3FsIWBTRUxFQ1QgKiBGUk9NIGFocF9ldmFsdWF0aW9ucyBXSEVSRSB1c2VyX25hbWUgPSAke3VzZXJOYW1lfWBcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBGZXRjaGVkIGV2YWx1YXRpb24gZm9yIHVzZXIgJHt1c2VyTmFtZX0uIEZvdW5kOiAke3Jlcy5sZW5ndGggPiAwfWApXHJcbiAgICByZXR1cm4gcmVzLmxlbmd0aCA/IHBhcnNlUm93KHJlc1swXSkgOiBudWxsXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJLdWxsYW7EsWPEsSBBSFAgdmVyaXNpIGdldGlybWUgaGF0YXPEsTpcIiwgZXJyb3IpXHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGV0YWlsczpcIiwge1xyXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICB1c2VyTmFtZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBpbi1tZW1vcnlcclxuICAgIHJldHVybiBtZW1GaW5kQnlVc2VyKHVzZXJOYW1lKVxyXG4gIH1cclxufVxyXG5cclxuLyogREVMRVRFIHNpbmdsZSAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQUhQRXZhbHVhdGlvbihpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgZnJvbSBpbi1tZW1vcnk6ICR7aWR9YClcclxuICAgIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChlKSA9PiBlLmlkID09PSBpZClcclxuICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICBtZW0uc3BsaWNlKGksIDEpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBEZWxldGVkIGZyb20gaW4tbWVtb3J5LiBSZW1haW5pbmcgY291bnQ6ICR7bWVtLmxlbmd0aH1gKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJJdGVtIG5vdCBmb3VuZCBpbiBpbi1tZW1vcnkgc3RvcmFnZVwiKVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgYXdhaXQgaW5pdFByb21pc2VcclxuICAgIGNvbnNvbGUubG9nKGBEZWxldGluZyBldmFsdWF0aW9uIHdpdGggSUQ6ICR7aWR9YClcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbCFgREVMRVRFIEZST00gYWhwX2V2YWx1YXRpb25zIFdIRVJFIGlkID0gJHtpZH0gUkVUVVJOSU5HIGlkYFxyXG4gICAgY29uc3QgZGVsZXRlZCA9IHJlc3VsdC5sZW5ndGggPiAwXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlIG9wZXJhdGlvbiBjb21wbGV0ZWQuIERlbGV0ZWQ6ICR7ZGVsZXRlZH1gKVxyXG4gICAgcmV0dXJuIGRlbGV0ZWRcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgTmVvbjogRXJyb3IgZGVsZXRpbmcgc2luZ2xlIGV2YWx1YXRpb24gd2l0aCBJRCAke2lkfTpgLCBlcnJvcilcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXRhaWxzOlwiLCB7XHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIGlkLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3IsXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG4vKiBERUxFVEUgbXVsdGlwbGUgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU11bHRpcGxlQUhQRXZhbHVhdGlvbnMoZXZhbHVhdGlvbklkczogc3RyaW5nW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBpZiAoIW5lb25SZWFkeSkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgbXVsdGlwbGUgZnJvbSBpbi1tZW1vcnk6ICR7ZXZhbHVhdGlvbklkcy5sZW5ndGh9IGl0ZW1zYCxcclxuICAgIClcclxuICAgIGxldCBkZWxldGVkQ291bnQgPSAwXHJcbiAgICBldmFsdWF0aW9uSWRzLmZvckVhY2goKGlkKSA9PiB7XHJcbiAgICAgIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChyKSA9PiByLmlkID09PSBpZClcclxuICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgbWVtLnNwbGljZShpLCAxKVxyXG4gICAgICAgIGRlbGV0ZWRDb3VudCsrXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICBjb25zb2xlLmxvZyhgRGVsZXRlZCAke2RlbGV0ZWRDb3VudH0gaXRlbXMgZnJvbSBpbi1tZW1vcnkuIFJlbWFpbmluZyBjb3VudDogJHttZW0ubGVuZ3RofWApXHJcbiAgICByZXR1cm4gZGVsZXRlZENvdW50ID4gMFxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGlmIChldmFsdWF0aW9uSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIk5lb246IE5vIGV2YWx1YXRpb24gSURzIHByb3ZpZGVkIGZvciBtdWx0aXBsZSBkZWxldGVcIilcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coYERlbGV0aW5nIG11bHRpcGxlIGV2YWx1YXRpb25zOiAke2V2YWx1YXRpb25JZHMubGVuZ3RofSBpdGVtc2ApXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWwhYERFTEVURSBGUk9NIGFocF9ldmFsdWF0aW9ucyBXSEVSRSBpZCA9IEFOWSgke2V2YWx1YXRpb25JZHN9KSBSRVRVUk5JTkcgaWRgXHJcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSByZXN1bHQubGVuZ3RoXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlZCAke2RlbGV0ZWRDb3VudH0gb3V0IG9mICR7ZXZhbHVhdGlvbklkcy5sZW5ndGh9IGV2YWx1YXRpb25zYClcclxuICAgIHJldHVybiBkZWxldGVkQ291bnQgPiAwXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYE5lb246IEVycm9yIGRlbGV0aW5nIG11bHRpcGxlIGV2YWx1YXRpb25zOmAsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgZXZhbHVhdGlvbklkcyxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogREVMRVRFIGFsbCAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsQUhQRXZhbHVhdGlvbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgYWxsIGZyb20gaW4tbWVtb3J5YClcclxuICAgIGNvbnN0IHByZXZpb3VzQ291bnQgPSBtZW0ubGVuZ3RoXHJcbiAgICBtZW0ubGVuZ3RoID0gMFxyXG4gICAgY29uc29sZS5sb2coYERlbGV0ZWQgYWxsICR7cHJldmlvdXNDb3VudH0gaXRlbXMgZnJvbSBpbi1tZW1vcnlgKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coXCJEZWxldGluZyBhbGwgZXZhbHVhdGlvbnMgZnJvbSBOZW9uLi4uXCIpXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWwhYERFTEVURSBGUk9NIGFocF9ldmFsdWF0aW9ucyBSRVRVUk5JTkcgaWRgXHJcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSByZXN1bHQubGVuZ3RoXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlZCBhbGwgJHtkZWxldGVkQ291bnR9IGV2YWx1YXRpb25zYClcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJOZW9uOiBFcnJvciBkZWxldGluZyBhbGwgZXZhbHVhdGlvbnM6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogQ2FsY3VsYXRlIGF2ZXJhZ2Ugd2VpZ2h0cyAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZVdlaWdodHMoZXZhbHVhdGlvbnM6IEFIUEV2YWx1YXRpb25bXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xyXG4gIGlmIChldmFsdWF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiB7fVxyXG5cclxuICBjb25zdCBhbGxXZWlnaHRzID0gZXZhbHVhdGlvbnMubWFwKChldmFsdWF0aW9uKSA9PiBldmFsdWF0aW9uLmdsb2JhbF93ZWlnaHRzKVxyXG4gIGNvbnN0IGNyaXRlcmlhSWRzID0gT2JqZWN0LmtleXMoYWxsV2VpZ2h0c1swXSB8fCB7fSlcclxuICBjb25zdCBhdmVyYWdlV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XHJcblxyXG4gIGNyaXRlcmlhSWRzLmZvckVhY2goKGNyaXRlcmlhSWQpID0+IHtcclxuICAgIGNvbnN0IHdlaWdodHMgPSBhbGxXZWlnaHRzLm1hcCgodykgPT4gd1tjcml0ZXJpYUlkXSB8fCAwKVxyXG4gICAgYXZlcmFnZVdlaWdodHNbY3JpdGVyaWFJZF0gPSB3ZWlnaHRzLnJlZHVjZSgoc3VtLCB3ZWlnaHQpID0+IHN1bSArIHdlaWdodCwgMCkgLyB3ZWlnaHRzLmxlbmd0aFxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBhdmVyYWdlV2VpZ2h0c1xyXG59XHJcblxyXG4vKiBTdG9yYWdlIHN0YXRzICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHMoKSB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsRXZhbHVhdGlvbnM6IG1lbS5sZW5ndGgsXHJcbiAgICAgIGxhc3RVcGRhdGVkOlxyXG4gICAgICAgIG1lbS5sZW5ndGggPiAwXHJcbiAgICAgICAgICA/IG1lbS5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLnVwZGF0ZWRfYXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEudXBkYXRlZF9hdCkuZ2V0VGltZSgpKVswXS51cGRhdGVkX2F0XHJcbiAgICAgICAgICA6IG51bGwsXHJcbiAgICAgIHN0b3JhZ2U6IFwiaW4tbWVtb3J5XCIsXHJcbiAgICAgIGNvbm5lY3Rpb25FcnJvcixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsIWBcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIENPVU5UKCopIGFzIHRvdGFsX2V2YWx1YXRpb25zLFxyXG4gICAgICAgIE1BWCh1cGRhdGVkX2F0KSBhcyBsYXN0X3VwZGF0ZWRcclxuICAgICAgRlJPTSBhaHBfZXZhbHVhdGlvbnNcclxuICAgIGBcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEV2YWx1YXRpb25zOiBOdW1iZXIocmVzdWx0WzBdLnRvdGFsX2V2YWx1YXRpb25zKSxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IHJlc3VsdFswXS5sYXN0X3VwZGF0ZWQsXHJcbiAgICAgIHN0b3JhZ2U6IFwibmVvblwiLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3I6IG51bGwsXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCLEsHN0YXRpc3RpayBhbG1hIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxFdmFsdWF0aW9uczogMCxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IG51bGwsXHJcbiAgICAgIHN0b3JhZ2U6IFwiZXJyb3JcIixcclxuICAgICAgY29ubmVjdGlvbkVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogRGF0YWJhc2UgY29ubmVjdGlvbiBjaGVjayAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEYXRhYmFzZUNvbm5lY3Rpb24oKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBEYXRhYmFzZSBjb25uZWN0aW9uIGNoZWNrIGZhaWxlZDogJHtjb25uZWN0aW9uRXJyb3J9YClcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRQcm9taXNlXHJcbiAgICAvLyBUZXN0IHRoZSBjb25uZWN0aW9uIHdpdGggYSBzaW1wbGUgcXVlcnlcclxuICAgIGF3YWl0IHNxbCFgU0VMRUNUIDEgYXMgdGVzdGBcclxuICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2UgY29ubmVjdGlvbiB0ZXN0IHN1Y2Nlc3NmdWxcIilcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogU2ltcGxlIGNvbm5lY3Rpb24gc3RhdHVzIGNoZWNrICh3aXRob3V0IGFjdHVhbCBxdWVyeSkgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YWJhc2VSZWFkeSgpOiBib29sZWFuIHtcclxuICByZXR1cm4gbmVvblJlYWR5ICYmIHNxbCAhPT0gbnVsbFxyXG59XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuLyogIFV0aWxpdHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5mdW5jdGlvbiBwYXJzZVJvdyhyb3c6IGFueSk6IEFIUEV2YWx1YXRpb24ge1xyXG4gIGNvbnN0IHNhZmVKc29uUGFyc2UgPSAodmFsdWU6IGFueSwgZmFsbGJhY2s6IGFueSA9IHt9KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZSAvLyBBbHJlYWR5IHBhcnNlZFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSlNPTiBwYXJzZSBlcnJvciBmb3IgdmFsdWU6XCIsIHZhbHVlLCBlcnJvcilcclxuICAgICAgICByZXR1cm4gZmFsbGJhY2tcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiByb3cuaWQsXHJcbiAgICB1c2VyX25hbWU6IHJvdy51c2VyX25hbWUsXHJcbiAgICBjcml0ZXJpYV93ZWlnaHRzOiBzYWZlSnNvblBhcnNlKHJvdy5jcml0ZXJpYV93ZWlnaHRzLCB7fSksXHJcbiAgICBnbG9iYWxfd2VpZ2h0czogc2FmZUpzb25QYXJzZShyb3cuZ2xvYmFsX3dlaWdodHMsIHt9KSxcclxuICAgIGNvbnNpc3RlbmN5X3Jlc3VsdHM6IHNhZmVKc29uUGFyc2Uocm93LmNvbnNpc3RlbmN5X3Jlc3VsdHMsIHt9KSxcclxuICAgIGhpZXJhcmNoeV9kYXRhOiBzYWZlSnNvblBhcnNlKHJvdy5oaWVyYXJjaHlfZGF0YSwge30pLFxyXG4gICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXHJcbiAgICB1cGRhdGVkX2F0OiByb3cudXBkYXRlZF9hdCxcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcclxuICByZXR1cm4gRGF0ZS5ub3coKS50b1N0cmluZygzNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKVxyXG59XHJcblxyXG4vLyBFeHBvcnQgY29ubmVjdGlvbiBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cygpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbmVvblJlYWR5LFxyXG4gICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgaGFzRW52aXJvbm1lbnRVcmw6ICEhcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMLFxyXG4gICAgdXJsVmFsaWQ6IHByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTCA/IHZhbGlkYXRlRGF0YWJhc2VVcmwocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSA6IGZhbHNlLFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsibmVvbiIsInNxbCIsIm5lb25SZWFkeSIsImNvbm5lY3Rpb25FcnJvciIsInZhbGlkYXRlRGF0YWJhc2VVcmwiLCJ1cmwiLCJzdGFydHNXaXRoIiwidXJsT2JqIiwiVVJMIiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInByb2Nlc3MiLCJlbnYiLCJEQVRBQkFTRV9VUkwiLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJ3YXJuIiwiZSIsImVycm9yIiwibWVzc2FnZSIsImNyZWF0ZVRhYmxlcyIsImluaXRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtZW0iLCJtZW1GaW5kQnlVc2VyIiwidSIsImZpbmQiLCJ1c2VyX25hbWUiLCJtZW1TYXZlIiwicm93IiwiaSIsImZpbmRJbmRleCIsInB1c2giLCJpbml0aWFsaXplRGF0YWJhc2UiLCJzYXZlQUhQRXZhbHVhdGlvbiIsInVzZXJOYW1lIiwiY3JpdGVyaWFXZWlnaHRzIiwiZ2xvYmFsV2VpZ2h0cyIsImNvbnNpc3RlbmN5UmVzdWx0cyIsImhpZXJhcmNoeURhdGEiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJpZCIsImdlbmVyYXRlSWQiLCJjcml0ZXJpYV93ZWlnaHRzIiwiZ2xvYmFsX3dlaWdodHMiLCJjb25zaXN0ZW5jeV9yZXN1bHRzIiwiaGllcmFyY2h5X2RhdGEiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImV4aXN0aW5nIiwibGVuZ3RoIiwicmVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlUm93Iiwic3RhY2siLCJnZXRBbGxBSFBFdmFsdWF0aW9ucyIsIm1hcCIsImdldEFIUEV2YWx1YXRpb25CeVVzZXIiLCJkZWxldGVBSFBFdmFsdWF0aW9uIiwic3BsaWNlIiwicmVzdWx0IiwiZGVsZXRlZCIsImRlbGV0ZU11bHRpcGxlQUhQRXZhbHVhdGlvbnMiLCJldmFsdWF0aW9uSWRzIiwiZGVsZXRlZENvdW50IiwiZm9yRWFjaCIsInIiLCJkZWxldGVBbGxBSFBFdmFsdWF0aW9ucyIsInByZXZpb3VzQ291bnQiLCJjYWxjdWxhdGVBdmVyYWdlV2VpZ2h0cyIsImV2YWx1YXRpb25zIiwiYWxsV2VpZ2h0cyIsImV2YWx1YXRpb24iLCJjcml0ZXJpYUlkcyIsIk9iamVjdCIsImtleXMiLCJhdmVyYWdlV2VpZ2h0cyIsImNyaXRlcmlhSWQiLCJ3ZWlnaHRzIiwidyIsInJlZHVjZSIsInN1bSIsIndlaWdodCIsImdldFN0b3JhZ2VTdGF0cyIsInRvdGFsRXZhbHVhdGlvbnMiLCJsYXN0VXBkYXRlZCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJzdG9yYWdlIiwiTnVtYmVyIiwidG90YWxfZXZhbHVhdGlvbnMiLCJsYXN0X3VwZGF0ZWQiLCJjaGVja0RhdGFiYXNlQ29ubmVjdGlvbiIsImlzRGF0YWJhc2VSZWFkeSIsInNhZmVKc29uUGFyc2UiLCJ2YWx1ZSIsImZhbGxiYWNrIiwicGFyc2UiLCJ0b1N0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJoYXNFbnZpcm9ubWVudFVybCIsInVybFZhbGlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/neon-db.ts\n"));

/***/ })

});