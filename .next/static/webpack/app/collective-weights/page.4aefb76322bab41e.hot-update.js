"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/collective-weights/page",{

/***/ "(app-pages-browser)/./lib/neon-db.ts":
/*!************************!*\
  !*** ./lib/neon-db.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAverageWeights: () => (/* binding */ calculateAverageWeights),\n/* harmony export */   checkDatabaseConnection: () => (/* binding */ checkDatabaseConnection),\n/* harmony export */   deleteAHPEvaluation: () => (/* binding */ deleteAHPEvaluation),\n/* harmony export */   deleteAllAHPEvaluations: () => (/* binding */ deleteAllAHPEvaluations),\n/* harmony export */   deleteMultipleAHPEvaluations: () => (/* binding */ deleteMultipleAHPEvaluations),\n/* harmony export */   getAHPEvaluationByUser: () => (/* binding */ getAHPEvaluationByUser),\n/* harmony export */   getAllAHPEvaluations: () => (/* binding */ getAllAHPEvaluations),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   initializeDatabase: () => (/* binding */ initializeDatabase),\n/* harmony export */   isDatabaseReady: () => (/* binding */ isDatabaseReady),\n/* harmony export */   saveAHPEvaluation: () => (/* binding */ saveAHPEvaluation)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var _neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neondatabase/serverless */ \"(app-pages-browser)/./node_modules/@neondatabase/serverless/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE TABLE IF NOT EXISTS ahp_evaluations (\\n        id TEXT PRIMARY KEY,\\n        user_name TEXT NOT NULL,\\n        criteria_weights JSONB NOT NULL,\\n        global_weights JSONB NOT NULL,\\n        consistency_results JSONB NOT NULL,\\n        hierarchy_data JSONB NOT NULL,\\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\\n      )\\n    \"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE INDEX IF NOT EXISTS idx_ahp_evaluations_user_name\\n      ON ahp_evaluations(user_name)\\n    \"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      CREATE INDEX IF NOT EXISTS idx_ahp_evaluations_updated_at\\n      ON ahp_evaluations(updated_at)\\n    \"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      SELECT id FROM ahp_evaluations WHERE user_name = \",\n        \"\\n    \"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject4() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n        UPDATE ahp_evaluations SET\\n          criteria_weights   = \",\n        \",\\n          global_weights     = \",\n        \",\\n          consistency_results= \",\n        \",\\n          hierarchy_data     = \",\n        \",\\n          updated_at         = \",\n        \"\\n        WHERE user_name      = \",\n        \"\\n        RETURNING *\\n      \"\n    ]);\n    _templateObject4 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject5() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      INSERT INTO ahp_evaluations (\\n        id, user_name, criteria_weights, global_weights,\\n        consistency_results, hierarchy_data, created_at, updated_at\\n      ) VALUES (\\n        \",\n        \", \",\n        \", \",\n        \", \",\n        \",\\n        \",\n        \", \",\n        \", \",\n        \", \",\n        \"\\n      )\\n      RETURNING *\\n    \"\n    ]);\n    _templateObject5 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject6() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT * FROM ahp_evaluations ORDER BY updated_at DESC\"\n    ]);\n    _templateObject6 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject7() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT * FROM ahp_evaluations WHERE user_name = \",\n        \"\"\n    ]);\n    _templateObject7 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject8() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations WHERE id = \",\n        \" RETURNING id\"\n    ]);\n    _templateObject8 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject9() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations WHERE id = ANY(\",\n        \") RETURNING id\"\n    ]);\n    _templateObject9 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject10() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"DELETE FROM ahp_evaluations RETURNING id\"\n    ]);\n    _templateObject10 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject11() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n      SELECT \\n        COUNT(*) as total_evaluations,\\n        MAX(updated_at) as last_updated\\n      FROM ahp_evaluations\\n    \"\n    ]);\n    _templateObject11 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject12() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"SELECT 1 as test\"\n    ]);\n    _templateObject12 = function() {\n        return data;\n    };\n    return data;\n}\n\n/* ------------------------------------------------------------------ */ /*  Neon connection (or in-memory fallback)                           */ /* ------------------------------------------------------------------ */ let sql = null;\nlet neonReady = false;\nlet connectionError = null;\n// DATABASE_URL validation\nfunction validateDatabaseUrl(url) {\n    try {\n        // Neon URL should start with postgresql:// or postgres://\n        if (!url.startsWith(\"postgresql://\") && !url.startsWith(\"postgres://\")) {\n            return false;\n        }\n        // Basic URL validation\n        const urlObj = new URL(url);\n        return urlObj.hostname && urlObj.pathname;\n    } catch (e) {\n        return false;\n    }\n}\ntry {\n    if (process.env.DATABASE_URL) {\n        console.log(\"DATABASE_URL found, validating...\");\n        if (!validateDatabaseUrl(process.env.DATABASE_URL)) {\n            throw new Error(\"Invalid DATABASE_URL format. Expected postgresql:// or postgres:// URL\");\n        }\n        console.log(\"DATABASE_URL is valid, creating Neon connection...\");\n        sql = (0,_neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__.neon)(process.env.DATABASE_URL);\n        neonReady = true;\n        console.log(\"Neon connection created successfully\");\n    } else {\n        console.log(\"DATABASE_URL not found, using in-memory storage\");\n        connectionError = \"DATABASE_URL environment variable not found\";\n    }\n} catch (e) {\n    console.error(\"Neon connection initialization error:\", e);\n    connectionError = e instanceof Error ? e.message : \"Unknown connection error\";\n    neonReady = false;\n}\n// TEST MODE: Simulate database connection for testing (only if no DATABASE_URL)\nif (!neonReady && \"development\" === 'development' && !process.env.DATABASE_URL) {\n    console.log(\"ðŸ§ª TEST MODE: Simulating database connection...\");\n    neonReady = true;\n    connectionError = null;\n    console.log(\"âœ… Test mode: Database connection simulated\");\n}\n/* ------------------------------------------------------------------ */ /*  One-time table creation promise                                   */ /* ------------------------------------------------------------------ */ async function createTables() {\n    if (!neonReady || !sql) {\n        console.log(\"Skipping table creation - Neon not ready\");\n        return;\n    }\n    try {\n        console.log(\"Creating tables if they don't exist...\");\n        // Create table first\n        await sql(_templateObject());\n        // Create indexes separately\n        await sql(_templateObject1());\n        await sql(_templateObject2());\n        console.log(\"Neon: ahp_evaluations table and indexes created successfully\");\n    } catch (error) {\n        console.error(\"Table creation error:\", error);\n        throw error;\n    }\n}\nconst initPromise = neonReady ? createTables() : Promise.resolve();\n/* ------------------------------------------------------------------ */ /*  In-memory storage (used when Neon isn't configured)               */ /* ------------------------------------------------------------------ */ const mem = [];\nconst memFindByUser = (u)=>{\n    var _mem_find;\n    return (_mem_find = mem.find((e)=>e.user_name === u)) !== null && _mem_find !== void 0 ? _mem_find : null;\n};\nconst memSave = (row)=>{\n    const i = mem.findIndex((e)=>e.user_name === row.user_name);\n    i === -1 ? mem.push(row) : mem[i] = row;\n    return row;\n};\n/* ------------------------------------------------------------------ */ /*  Public helpers                                                    */ /* ------------------------------------------------------------------ */ async function initializeDatabase() {\n    try {\n        await initPromise;\n        console.log(\"Database initialization completed\");\n    } catch (error) {\n        console.error(\"Database initialization failed:\", error);\n        throw error;\n    }\n}\n/* CREATE / UPDATE (upsert by user) */ async function saveAHPEvaluation(userName, criteriaWeights, globalWeights, consistencyResults, hierarchyData) {\n    const now = new Date().toISOString();\n    /* In-memory mode -------------------------------------------------- */ if (!neonReady) {\n        console.warn(\"âš ï¸  Neon DB not ready (\".concat(connectionError, \"), saving to in-memory for user: \").concat(userName));\n        console.warn(\"âš ï¸  This data will be LOST when the application restarts!\");\n        const row = {\n            id: generateId(),\n            user_name: userName,\n            criteria_weights: criteriaWeights,\n            global_weights: globalWeights,\n            consistency_results: consistencyResults,\n            hierarchy_data: hierarchyData,\n            created_at: now,\n            updated_at: now\n        };\n        return memSave(row);\n    }\n    /* Neon mode ------------------------------------------------------- */ try {\n        await initPromise;\n        console.log(\"Checking for existing evaluation for user: \".concat(userName));\n        const existing = await sql(_templateObject3(), userName);\n        if (existing.length) {\n            console.log(\"Updating existing evaluation for user: \".concat(userName));\n            const res = await sql(_templateObject4(), JSON.stringify(criteriaWeights), JSON.stringify(globalWeights), JSON.stringify(consistencyResults), JSON.stringify(hierarchyData), now, userName);\n            console.log(\"Neon: Updated evaluation for user \".concat(userName));\n            return parseRow(res[0]);\n        }\n        console.log(\"Creating new evaluation for user: \".concat(userName));\n        const res = await sql(_templateObject5(), generateId(), userName, JSON.stringify(criteriaWeights), JSON.stringify(globalWeights), JSON.stringify(consistencyResults), JSON.stringify(hierarchyData), now, now);\n        console.log(\"Neon: Inserted new evaluation for user \".concat(userName));\n        return parseRow(res[0]);\n    } catch (error) {\n        console.error(\"AHP kaydetme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            stack: error.stack,\n            userName,\n            connectionError\n        });\n        throw error;\n    }\n}\n/* READ - all */ async function getAllAHPEvaluations() {\n    if (!neonReady) {\n        console.warn(\"âš ï¸  Neon DB not ready (\".concat(connectionError, \"), getting all from in-memory. Count: \").concat(mem.length));\n        console.warn(\"âš ï¸  In-memory data will be LOST when the application restarts!\");\n        return [\n            ...mem\n        ] // Return a copy to avoid mutations\n        ;\n    }\n    try {\n        await initPromise;\n        console.log(\"Fetching all evaluations from Neon...\");\n        const res = await sql(_templateObject6());\n        console.log(\"Neon: Fetched \".concat(res.length, \" evaluations\"));\n        return res.map(parseRow);\n    } catch (error) {\n        console.error(\"AHP verilerini getirme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            stack: error.stack,\n            connectionError,\n            neonReady\n        });\n        // Fallback to in-memory if database fails\n        console.log(\"Falling back to in-memory storage due to database error\");\n        return [\n            ...mem\n        ];\n    }\n}\n/* READ - by user */ async function getAHPEvaluationByUser(userName) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), getting by user from in-memory: \").concat(userName));\n        return memFindByUser(userName);\n    }\n    try {\n        await initPromise;\n        console.log(\"Fetching evaluation for user: \".concat(userName));\n        const res = await sql(_templateObject7(), userName);\n        console.log(\"Neon: Fetched evaluation for user \".concat(userName, \". Found: \").concat(res.length > 0));\n        return res.length ? parseRow(res[0]) : null;\n    } catch (error) {\n        console.error(\"KullanÄ±cÄ± AHP verisi getirme hatasÄ±:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            userName,\n            connectionError\n        });\n        // Fallback to in-memory\n        return memFindByUser(userName);\n    }\n}\n/* DELETE single */ async function deleteAHPEvaluation(id) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting from in-memory: \").concat(id));\n        const i = mem.findIndex((e)=>e.id === id);\n        if (i !== -1) {\n            mem.splice(i, 1);\n            console.log(\"Deleted from in-memory. Remaining count: \".concat(mem.length));\n            return true;\n        }\n        console.log(\"Item not found in in-memory storage\");\n        return false;\n    }\n    try {\n        await initPromise;\n        console.log(\"Deleting evaluation with ID: \".concat(id));\n        const result = await sql(_templateObject8(), id);\n        const deleted = result.length > 0;\n        console.log(\"Neon: Delete operation completed. Deleted: \".concat(deleted));\n        return deleted;\n    } catch (error) {\n        console.error(\"Neon: Error deleting single evaluation with ID \".concat(id, \":\"), error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            id,\n            connectionError\n        });\n        return false;\n    }\n}\n/* DELETE multiple */ async function deleteMultipleAHPEvaluations(evaluationIds) {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting multiple from in-memory: \").concat(evaluationIds.length, \" items\"));\n        let deletedCount = 0;\n        evaluationIds.forEach((id)=>{\n            const i = mem.findIndex((r)=>r.id === id);\n            if (i !== -1) {\n                mem.splice(i, 1);\n                deletedCount++;\n            }\n        });\n        console.log(\"Deleted \".concat(deletedCount, \" items from in-memory. Remaining count: \").concat(mem.length));\n        return deletedCount > 0;\n    }\n    try {\n        if (evaluationIds.length === 0) {\n            console.log(\"Neon: No evaluation IDs provided for multiple delete\");\n            return true;\n        }\n        await initPromise;\n        console.log(\"Deleting multiple evaluations: \".concat(evaluationIds.length, \" items\"));\n        const result = await sql(_templateObject9(), evaluationIds);\n        const deletedCount = result.length;\n        console.log(\"Neon: Deleted \".concat(deletedCount, \" out of \").concat(evaluationIds.length, \" evaluations\"));\n        return deletedCount > 0;\n    } catch (error) {\n        console.error(\"Neon: Error deleting multiple evaluations:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            evaluationIds,\n            connectionError\n        });\n        return false;\n    }\n}\n/* DELETE all */ async function deleteAllAHPEvaluations() {\n    if (!neonReady) {\n        console.log(\"Neon DB not ready (\".concat(connectionError, \"), deleting all from in-memory\"));\n        const previousCount = mem.length;\n        mem.length = 0;\n        console.log(\"Deleted all \".concat(previousCount, \" items from in-memory\"));\n        return true;\n    }\n    try {\n        await initPromise;\n        console.log(\"Deleting all evaluations from Neon...\");\n        const result = await sql(_templateObject10());\n        const deletedCount = result.length;\n        console.log(\"Neon: Deleted all \".concat(deletedCount, \" evaluations\"));\n        return true;\n    } catch (error) {\n        console.error(\"Neon: Error deleting all evaluations:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            connectionError\n        });\n        return false;\n    }\n}\n/* Calculate average weights */ function calculateAverageWeights(evaluations) {\n    if (evaluations.length === 0) return {};\n    const allWeights = evaluations.map((evaluation)=>evaluation.global_weights);\n    const criteriaIds = Object.keys(allWeights[0] || {});\n    const averageWeights = {};\n    criteriaIds.forEach((criteriaId)=>{\n        const weights = allWeights.map((w)=>w[criteriaId] || 0);\n        averageWeights[criteriaId] = weights.reduce((sum, weight)=>sum + weight, 0) / weights.length;\n    });\n    return averageWeights;\n}\n/* Storage stats */ async function getStorageStats() {\n    if (!neonReady) {\n        return {\n            totalEvaluations: mem.length,\n            lastUpdated: mem.length > 0 ? mem.sort((a, b)=>new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime())[0].updated_at : null,\n            storage: \"in-memory\",\n            connectionError\n        };\n    }\n    try {\n        await initPromise;\n        const result = await sql(_templateObject11());\n        return {\n            totalEvaluations: Number(result[0].total_evaluations),\n            lastUpdated: result[0].last_updated,\n            storage: \"neon\",\n            connectionError: null\n        };\n    } catch (error) {\n        console.error(\"Ä°statistik alma hatasÄ±:\", error);\n        return {\n            totalEvaluations: 0,\n            lastUpdated: null,\n            storage: \"error\",\n            connectionError: error.message\n        };\n    }\n}\n/* Database connection check */ async function checkDatabaseConnection() {\n    if (!neonReady) {\n        console.log(\"Database connection check failed: \".concat(connectionError));\n        return false;\n    }\n    try {\n        await initPromise;\n        // Test the connection with a simple query\n        await sql(_templateObject12());\n        console.log(\"Database connection test successful\");\n        return true;\n    } catch (error) {\n        console.error(\"Database connection test failed:\", error);\n        return false;\n    }\n}\n/* Simple connection status check (without actual query) */ function isDatabaseReady() {\n    return neonReady && sql !== null;\n}\n/* ------------------------------------------------------------------ */ /*  Utility                                                           */ /* ------------------------------------------------------------------ */ function parseRow(row) {\n    const safeJsonParse = function(value) {\n        let fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (typeof value === \"object\" && value !== null) {\n            return value // Already parsed\n            ;\n        }\n        if (typeof value === \"string\") {\n            try {\n                return JSON.parse(value);\n            } catch (error) {\n                console.error(\"JSON parse error for value:\", value, error);\n                return fallback;\n            }\n        }\n        return fallback;\n    };\n    return {\n        id: row.id,\n        user_name: row.user_name,\n        criteria_weights: safeJsonParse(row.criteria_weights, {}),\n        global_weights: safeJsonParse(row.global_weights, {}),\n        consistency_results: safeJsonParse(row.consistency_results, {}),\n        hierarchy_data: safeJsonParse(row.hierarchy_data, {}),\n        created_at: row.created_at,\n        updated_at: row.updated_at\n    };\n}\nfunction generateId() {\n    return Date.now().toString(36) + Math.random().toString(36).slice(2);\n}\n// Export connection status for debugging\nfunction getConnectionStatus() {\n    return {\n        neonReady,\n        connectionError,\n        hasEnvironmentUrl: !!process.env.DATABASE_URL,\n        urlValid: process.env.DATABASE_URL ? validateDatabaseUrl(process.env.DATABASE_URL) : false\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uZW9uLWRiLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFFL0Msc0VBQXNFLEdBQ3RFLHNFQUFzRSxHQUN0RSxzRUFBc0UsR0FDdEUsSUFBSUMsTUFBc0M7QUFDMUMsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxrQkFBaUM7QUFFckMsMEJBQTBCO0FBQzFCLFNBQVNDLG9CQUFvQkMsR0FBVztJQUN0QyxJQUFJO1FBQ0YsMERBQTBEO1FBQzFELElBQUksQ0FBQ0EsSUFBSUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDRCxJQUFJQyxVQUFVLENBQUMsZ0JBQWdCO1lBQ3RFLE9BQU87UUFDVDtRQUVBLHVCQUF1QjtRQUN2QixNQUFNQyxTQUFTLElBQUlDLElBQUlIO1FBQ3ZCLE9BQU9FLE9BQU9FLFFBQVEsSUFBSUYsT0FBT0csUUFBUTtJQUMzQyxFQUFFLFVBQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUVBLElBQUk7SUFDRixJQUFJQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLFlBQVksRUFBRTtRQUM1QkMsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSSxDQUFDWCxvQkFBb0JPLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWSxHQUFHO1lBQ2xELE1BQU0sSUFBSUcsTUFBTTtRQUNsQjtRQUVBRixRQUFRQyxHQUFHLENBQUM7UUFDWmQsTUFBTUQsOERBQUlBLENBQUNXLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWTtRQUNuQ1gsWUFBWTtRQUNaWSxRQUFRQyxHQUFHLENBQUM7SUFDZCxPQUFPO1FBQ0xELFFBQVFDLEdBQUcsQ0FBQztRQUNaWixrQkFB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QkFDcEQsT0FBT3FGO1lBQ1Q7UUFDRjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPO1FBQ0wxRCxJQUFJZixJQUFJZSxFQUFFO1FBQ1ZqQixXQUFXRSxJQUFJRixTQUFTO1FBQ3hCbUIsa0JBQWtCc0QsY0FBY3ZFLElBQUlpQixnQkFBZ0IsRUFBRSxDQUFDO1FBQ3ZEQyxnQkFBZ0JxRCxjQUFjdkUsSUFBSWtCLGNBQWMsRUFBRSxDQUFDO1FBQ25EQyxxQkFBcUJvRCxjQUFjdkUsSUFBSW1CLG1CQUFtQixFQUFFLENBQUM7UUFDN0RDLGdCQUFnQm1ELGNBQWN2RSxJQUFJb0IsY0FBYyxFQUFFLENBQUM7UUFDbkRDLFlBQVlyQixJQUFJcUIsVUFBVTtRQUMxQkMsWUFBWXRCLElBQUlzQixVQUFVO0lBQzVCO0FBQ0Y7QUFFQSxTQUFTTjtJQUNQLE9BQU9KLEtBQUtELEdBQUcsR0FBR2dFLFFBQVEsQ0FBQyxNQUFNQyxLQUFLQyxNQUFNLEdBQUdGLFFBQVEsQ0FBQyxJQUFJRyxLQUFLLENBQUM7QUFDcEU7QUFFQSx5Q0FBeUM7QUFDbEMsU0FBU0M7SUFDZCxPQUFPO1FBQ0wzRztRQUNBQztRQUNBMkcsbUJBQW1CLENBQUMsQ0FBQ25HLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWTtRQUM3Q2tHLFVBQVVwRyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLFlBQVksR0FBR1Qsb0JBQW9CTyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLFlBQVksSUFBSTtJQUN2RjtBQUNGIiwic291cmNlcyI6WyJEOlxcU3VydWN1cHVhbnNpc3RlbWkwODIwMjVcXFNQU19EaXNpcGxpbkF5ci1tbC1fMDQwOTIwMjVcXGxpYlxcbmVvbi1kYi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBuZW9uIH0gZnJvbSBcIkBuZW9uZGF0YWJhc2Uvc2VydmVybGVzc1wiXHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuLyogIE5lb24gY29ubmVjdGlvbiAob3IgaW4tbWVtb3J5IGZhbGxiYWNrKSAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5sZXQgc3FsOiBSZXR1cm5UeXBlPHR5cGVvZiBuZW9uPiB8IG51bGwgPSBudWxsXHJcbmxldCBuZW9uUmVhZHkgPSBmYWxzZVxyXG5sZXQgY29ubmVjdGlvbkVycm9yOiBzdHJpbmcgfCBudWxsID0gbnVsbFxyXG5cclxuLy8gREFUQUJBU0VfVVJMIHZhbGlkYXRpb25cclxuZnVuY3Rpb24gdmFsaWRhdGVEYXRhYmFzZVVybCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBOZW9uIFVSTCBzaG91bGQgc3RhcnQgd2l0aCBwb3N0Z3Jlc3FsOi8vIG9yIHBvc3RncmVzOi8vXHJcbiAgICBpZiAoIXVybC5zdGFydHNXaXRoKFwicG9zdGdyZXNxbDovL1wiKSAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJwb3N0Z3JlczovL1wiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICAvLyBCYXNpYyBVUkwgdmFsaWRhdGlvblxyXG4gICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpXHJcbiAgICByZXR1cm4gdXJsT2JqLmhvc3RuYW1lICYmIHVybE9iai5wYXRobmFtZVxyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG50cnkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkwpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiREFUQUJBU0VfVVJMIGZvdW5kLCB2YWxpZGF0aW5nLi4uXCIpXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZURhdGFiYXNlVXJsKHByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEQVRBQkFTRV9VUkwgZm9ybWF0LiBFeHBlY3RlZCBwb3N0Z3Jlc3FsOi8vIG9yIHBvc3RncmVzOi8vIFVSTFwiKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiREFUQUJBU0VfVVJMIGlzIHZhbGlkLCBjcmVhdGluZyBOZW9uIGNvbm5lY3Rpb24uLi5cIilcclxuICAgIHNxbCA9IG5lb24ocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKVxyXG4gICAgbmVvblJlYWR5ID0gdHJ1ZVxyXG4gICAgY29uc29sZS5sb2coXCJOZW9uIGNvbm5lY3Rpb24gY3JlYXRlZCBzdWNjZXNzZnVsbHlcIilcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS5sb2coXCJEQVRBQkFTRV9VUkwgbm90IGZvdW5kLCB1c2luZyBpbi1tZW1vcnkgc3RvcmFnZVwiKVxyXG4gICAgY29ubmVjdGlvbkVycm9yID0gXCJEQVRBQkFTRV9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUgbm90IGZvdW5kXCJcclxuICB9XHJcbn0gY2F0Y2ggKGUpIHtcclxuICBjb25zb2xlLmVycm9yKFwiTmVvbiBjb25uZWN0aW9uIGluaXRpYWxpemF0aW9uIGVycm9yOlwiLCBlKVxyXG4gIGNvbm5lY3Rpb25FcnJvciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFwiVW5rbm93biBjb25uZWN0aW9uIGVycm9yXCJcclxuICBuZW9uUmVhZHkgPSBmYWxzZVxyXG59XHJcblxyXG4vLyBURVNUIE1PREU6IFNpbXVsYXRlIGRhdGFiYXNlIGNvbm5lY3Rpb24gZm9yIHRlc3RpbmcgKG9ubHkgaWYgbm8gREFUQUJBU0VfVVJMKVxyXG5pZiAoIW5lb25SZWFkeSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSB7XHJcbiAgY29uc29sZS5sb2coXCLwn6eqIFRFU1QgTU9ERTogU2ltdWxhdGluZyBkYXRhYmFzZSBjb25uZWN0aW9uLi4uXCIpXHJcbiAgbmVvblJlYWR5ID0gdHJ1ZVxyXG4gIGNvbm5lY3Rpb25FcnJvciA9IG51bGxcclxuICBjb25zb2xlLmxvZyhcIuKchSBUZXN0IG1vZGU6IERhdGFiYXNlIGNvbm5lY3Rpb24gc2ltdWxhdGVkXCIpXHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgT25lLXRpbWUgdGFibGUgY3JlYXRpb24gcHJvbWlzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlcygpIHtcclxuICBpZiAoIW5lb25SZWFkeSB8fCAhc3FsKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlNraXBwaW5nIHRhYmxlIGNyZWF0aW9uIC0gTmVvbiBub3QgcmVhZHlcIilcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgdGFibGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3QuLi5cIilcclxuXHJcbiAgICAvLyBDcmVhdGUgdGFibGUgZmlyc3RcclxuICAgIGF3YWl0IHNxbGBcclxuICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgYWhwX2V2YWx1YXRpb25zIChcclxuICAgICAgICBpZCBURVhUIFBSSU1BUlkgS0VZLFxyXG4gICAgICAgIHVzZXJfbmFtZSBURVhUIE5PVCBOVUxMLFxyXG4gICAgICAgIGNyaXRlcmlhX3dlaWdodHMgSlNPTkIgTk9UIE5VTEwsXHJcbiAgICAgICAgZ2xvYmFsX3dlaWdodHMgSlNPTkIgTk9UIE5VTEwsXHJcbiAgICAgICAgY29uc2lzdGVuY3lfcmVzdWx0cyBKU09OQiBOT1QgTlVMTCxcclxuICAgICAgICBoaWVyYXJjaHlfZGF0YSBKU09OQiBOT1QgTlVMTCxcclxuICAgICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKClcclxuICAgICAgKVxyXG4gICAgYFxyXG5cclxuICAgIC8vIENyZWF0ZSBpbmRleGVzIHNlcGFyYXRlbHlcclxuICAgIGF3YWl0IHNxbGBcclxuICAgICAgQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2FocF9ldmFsdWF0aW9uc191c2VyX25hbWVcclxuICAgICAgT04gYWhwX2V2YWx1YXRpb25zKHVzZXJfbmFtZSlcclxuICAgIGBcclxuXHJcbiAgICBhd2FpdCBzcWxgXHJcbiAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9haHBfZXZhbHVhdGlvbnNfdXBkYXRlZF9hdFxyXG4gICAgICBPTiBhaHBfZXZhbHVhdGlvbnModXBkYXRlZF9hdClcclxuICAgIGBcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIk5lb246IGFocF9ldmFsdWF0aW9ucyB0YWJsZSBhbmQgaW5kZXhlcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiVGFibGUgY3JlYXRpb24gZXJyb3I6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gbmVvblJlYWR5ID8gY3JlYXRlVGFibGVzKCkgOiBQcm9taXNlLnJlc29sdmUoKVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBUeXBlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBSFBFdmFsdWF0aW9uIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdXNlcl9uYW1lOiBzdHJpbmdcclxuICBjcml0ZXJpYV93ZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+XHJcbiAgZ2xvYmFsX3dlaWdodHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxuICBjb25zaXN0ZW5jeV9yZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgaGllcmFyY2h5X2RhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcltdW10+XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgSW4tbWVtb3J5IHN0b3JhZ2UgKHVzZWQgd2hlbiBOZW9uIGlzbid0IGNvbmZpZ3VyZWQpICAgICAgICAgICAgICAgKi9cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbmNvbnN0IG1lbTogQUhQRXZhbHVhdGlvbltdID0gW11cclxuY29uc3QgbWVtRmluZEJ5VXNlciA9ICh1OiBzdHJpbmcpID0+IG1lbS5maW5kKChlKSA9PiBlLnVzZXJfbmFtZSA9PT0gdSkgPz8gbnVsbFxyXG5jb25zdCBtZW1TYXZlID0gKHJvdzogQUhQRXZhbHVhdGlvbikgPT4ge1xyXG4gIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChlKSA9PiBlLnVzZXJfbmFtZSA9PT0gcm93LnVzZXJfbmFtZSlcclxuICBpID09PSAtMSA/IG1lbS5wdXNoKHJvdykgOiAobWVtW2ldID0gcm93KVxyXG4gIHJldHVybiByb3dcclxufVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICBQdWJsaWMgaGVscGVycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVEYXRhYmFzZSgpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgaW5pdFByb21pc2VcclxuICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2UgaW5pdGlhbGl6YXRpb24gY29tcGxldGVkXCIpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbi8qIENSRUFURSAvIFVQREFURSAodXBzZXJ0IGJ5IHVzZXIpICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlQUhQRXZhbHVhdGlvbihcclxuICB1c2VyTmFtZTogc3RyaW5nLFxyXG4gIGNyaXRlcmlhV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcclxuICBnbG9iYWxXZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxyXG4gIGNvbnNpc3RlbmN5UmVzdWx0czogUmVjb3JkPHN0cmluZywgYW55PixcclxuICBoaWVyYXJjaHlEYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXVtdPixcclxuKTogUHJvbWlzZTxBSFBFdmFsdWF0aW9uPiB7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcblxyXG4gIC8qIEluLW1lbW9yeSBtb2RlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgc2F2aW5nIHRvIGluLW1lbW9yeSBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc29sZS53YXJuKGDimqDvuI8gIFRoaXMgZGF0YSB3aWxsIGJlIExPU1Qgd2hlbiB0aGUgYXBwbGljYXRpb24gcmVzdGFydHMhYClcclxuICAgIGNvbnN0IHJvdzogQUhQRXZhbHVhdGlvbiA9IHtcclxuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgICAgdXNlcl9uYW1lOiB1c2VyTmFtZSxcclxuICAgICAgY3JpdGVyaWFfd2VpZ2h0czogY3JpdGVyaWFXZWlnaHRzLFxyXG4gICAgICBnbG9iYWxfd2VpZ2h0czogZ2xvYmFsV2VpZ2h0cyxcclxuICAgICAgY29uc2lzdGVuY3lfcmVzdWx0czogY29uc2lzdGVuY3lSZXN1bHRzLFxyXG4gICAgICBoaWVyYXJjaHlfZGF0YTogaGllcmFyY2h5RGF0YSxcclxuICAgICAgY3JlYXRlZF9hdDogbm93LFxyXG4gICAgICB1cGRhdGVkX2F0OiBub3csXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVtU2F2ZShyb3cpXHJcbiAgfVxyXG5cclxuICAvKiBOZW9uIG1vZGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBmb3IgZXhpc3RpbmcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBzcWwhYFxyXG4gICAgICBTRUxFQ1QgaWQgRlJPTSBhaHBfZXZhbHVhdGlvbnMgV0hFUkUgdXNlcl9uYW1lID0gJHt1c2VyTmFtZX1cclxuICAgIGBcclxuXHJcbiAgICBpZiAoZXhpc3RpbmcubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBleGlzdGluZyBldmFsdWF0aW9uIGZvciB1c2VyOiAke3VzZXJOYW1lfWApXHJcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHNxbCFgXHJcbiAgICAgICAgVVBEQVRFIGFocF9ldmFsdWF0aW9ucyBTRVRcclxuICAgICAgICAgIGNyaXRlcmlhX3dlaWdodHMgICA9ICR7SlNPTi5zdHJpbmdpZnkoY3JpdGVyaWFXZWlnaHRzKX0sXHJcbiAgICAgICAgICBnbG9iYWxfd2VpZ2h0cyAgICAgPSAke0pTT04uc3RyaW5naWZ5KGdsb2JhbFdlaWdodHMpfSxcclxuICAgICAgICAgIGNvbnNpc3RlbmN5X3Jlc3VsdHM9ICR7SlNPTi5zdHJpbmdpZnkoY29uc2lzdGVuY3lSZXN1bHRzKX0sXHJcbiAgICAgICAgICBoaWVyYXJjaHlfZGF0YSAgICAgPSAke0pTT04uc3RyaW5naWZ5KGhpZXJhcmNoeURhdGEpfSxcclxuICAgICAgICAgIHVwZGF0ZWRfYXQgICAgICAgICA9ICR7bm93fVxyXG4gICAgICAgIFdIRVJFIHVzZXJfbmFtZSAgICAgID0gJHt1c2VyTmFtZX1cclxuICAgICAgICBSRVRVUk5JTkcgKlxyXG4gICAgICBgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBOZW9uOiBVcGRhdGVkIGV2YWx1YXRpb24gZm9yIHVzZXIgJHt1c2VyTmFtZX1gKVxyXG4gICAgICByZXR1cm4gcGFyc2VSb3cocmVzWzBdKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBuZXcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3FsIWBcclxuICAgICAgSU5TRVJUIElOVE8gYWhwX2V2YWx1YXRpb25zIChcclxuICAgICAgICBpZCwgdXNlcl9uYW1lLCBjcml0ZXJpYV93ZWlnaHRzLCBnbG9iYWxfd2VpZ2h0cyxcclxuICAgICAgICBjb25zaXN0ZW5jeV9yZXN1bHRzLCBoaWVyYXJjaHlfZGF0YSwgY3JlYXRlZF9hdCwgdXBkYXRlZF9hdFxyXG4gICAgICApIFZBTFVFUyAoXHJcbiAgICAgICAgJHtnZW5lcmF0ZUlkKCl9LCAke3VzZXJOYW1lfSwgJHtKU09OLnN0cmluZ2lmeShjcml0ZXJpYVdlaWdodHMpfSwgJHtKU09OLnN0cmluZ2lmeShnbG9iYWxXZWlnaHRzKX0sXHJcbiAgICAgICAgJHtKU09OLnN0cmluZ2lmeShjb25zaXN0ZW5jeVJlc3VsdHMpfSwgJHtKU09OLnN0cmluZ2lmeShoaWVyYXJjaHlEYXRhKX0sICR7bm93fSwgJHtub3d9XHJcbiAgICAgIClcclxuICAgICAgUkVUVVJOSU5HICpcclxuICAgIGBcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBJbnNlcnRlZCBuZXcgZXZhbHVhdGlvbiBmb3IgdXNlciAke3VzZXJOYW1lfWApXHJcbiAgICByZXR1cm4gcGFyc2VSb3cocmVzWzBdKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiQUhQIGtheWRldG1lIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICB1c2VyTmFtZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG4vKiBSRUFEIC0gYWxsICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxBSFBFdmFsdWF0aW9ucygpOiBQcm9taXNlPEFIUEV2YWx1YXRpb25bXT4ge1xyXG4gIGlmICghbmVvblJlYWR5KSB7XHJcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgTmVvbiBEQiBub3QgcmVhZHkgKCR7Y29ubmVjdGlvbkVycm9yfSksIGdldHRpbmcgYWxsIGZyb20gaW4tbWVtb3J5LiBDb3VudDogJHttZW0ubGVuZ3RofWApXHJcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgSW4tbWVtb3J5IGRhdGEgd2lsbCBiZSBMT1NUIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlc3RhcnRzIWApXHJcbiAgICByZXR1cm4gWy4uLm1lbV0gLy8gUmV0dXJuIGEgY29weSB0byBhdm9pZCBtdXRhdGlvbnNcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coXCJGZXRjaGluZyBhbGwgZXZhbHVhdGlvbnMgZnJvbSBOZW9uLi4uXCIpXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBzcWwhYFNFTEVDVCAqIEZST00gYWhwX2V2YWx1YXRpb25zIE9SREVSIEJZIHVwZGF0ZWRfYXQgREVTQ2BcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBGZXRjaGVkICR7cmVzLmxlbmd0aH0gZXZhbHVhdGlvbnNgKVxyXG4gICAgcmV0dXJuIHJlcy5tYXAocGFyc2VSb3cpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJBSFAgdmVyaWxlcmluaSBnZXRpcm1lIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3IsXHJcbiAgICAgIG5lb25SZWFkeSxcclxuICAgIH0pXHJcblxyXG4gICAgLy8gRmFsbGJhY2sgdG8gaW4tbWVtb3J5IGlmIGRhdGFiYXNlIGZhaWxzXHJcbiAgICBjb25zb2xlLmxvZyhcIkZhbGxpbmcgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZSBkdWUgdG8gZGF0YWJhc2UgZXJyb3JcIilcclxuICAgIHJldHVybiBbLi4ubWVtXVxyXG4gIH1cclxufVxyXG5cclxuLyogUkVBRCAtIGJ5IHVzZXIgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFIUEV2YWx1YXRpb25CeVVzZXIodXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8QUhQRXZhbHVhdGlvbiB8IG51bGw+IHtcclxuICBpZiAoIW5lb25SZWFkeSkge1xyXG4gICAgY29uc29sZS5sb2coYE5lb24gREIgbm90IHJlYWR5ICgke2Nvbm5lY3Rpb25FcnJvcn0pLCBnZXR0aW5nIGJ5IHVzZXIgZnJvbSBpbi1tZW1vcnk6ICR7dXNlck5hbWV9YClcclxuICAgIHJldHVybiBtZW1GaW5kQnlVc2VyKHVzZXJOYW1lKVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRQcm9taXNlXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZhbHVhdGlvbiBmb3IgdXNlcjogJHt1c2VyTmFtZX1gKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3FsIWBTRUxFQ1QgKiBGUk9NIGFocF9ldmFsdWF0aW9ucyBXSEVSRSB1c2VyX25hbWUgPSAke3VzZXJOYW1lfWBcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uOiBGZXRjaGVkIGV2YWx1YXRpb24gZm9yIHVzZXIgJHt1c2VyTmFtZX0uIEZvdW5kOiAke3Jlcy5sZW5ndGggPiAwfWApXHJcbiAgICByZXR1cm4gcmVzLmxlbmd0aCA/IHBhcnNlUm93KHJlc1swXSkgOiBudWxsXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJLdWxsYW7EsWPEsSBBSFAgdmVyaXNpIGdldGlybWUgaGF0YXPEsTpcIiwgZXJyb3IpXHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGV0YWlsczpcIiwge1xyXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICB1c2VyTmFtZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBpbi1tZW1vcnlcclxuICAgIHJldHVybiBtZW1GaW5kQnlVc2VyKHVzZXJOYW1lKVxyXG4gIH1cclxufVxyXG5cclxuLyogREVMRVRFIHNpbmdsZSAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQUhQRXZhbHVhdGlvbihpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgZnJvbSBpbi1tZW1vcnk6ICR7aWR9YClcclxuICAgIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChlKSA9PiBlLmlkID09PSBpZClcclxuICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICBtZW0uc3BsaWNlKGksIDEpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBEZWxldGVkIGZyb20gaW4tbWVtb3J5LiBSZW1haW5pbmcgY291bnQ6ICR7bWVtLmxlbmd0aH1gKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJJdGVtIG5vdCBmb3VuZCBpbiBpbi1tZW1vcnkgc3RvcmFnZVwiKVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgYXdhaXQgaW5pdFByb21pc2VcclxuICAgIGNvbnNvbGUubG9nKGBEZWxldGluZyBldmFsdWF0aW9uIHdpdGggSUQ6ICR7aWR9YClcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbCFgREVMRVRFIEZST00gYWhwX2V2YWx1YXRpb25zIFdIRVJFIGlkID0gJHtpZH0gUkVUVVJOSU5HIGlkYFxyXG4gICAgY29uc3QgZGVsZXRlZCA9IHJlc3VsdC5sZW5ndGggPiAwXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlIG9wZXJhdGlvbiBjb21wbGV0ZWQuIERlbGV0ZWQ6ICR7ZGVsZXRlZH1gKVxyXG4gICAgcmV0dXJuIGRlbGV0ZWRcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgTmVvbjogRXJyb3IgZGVsZXRpbmcgc2luZ2xlIGV2YWx1YXRpb24gd2l0aCBJRCAke2lkfTpgLCBlcnJvcilcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXRhaWxzOlwiLCB7XHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIGlkLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3IsXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG4vKiBERUxFVEUgbXVsdGlwbGUgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU11bHRpcGxlQUhQRXZhbHVhdGlvbnMoZXZhbHVhdGlvbklkczogc3RyaW5nW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBpZiAoIW5lb25SZWFkeSkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgbXVsdGlwbGUgZnJvbSBpbi1tZW1vcnk6ICR7ZXZhbHVhdGlvbklkcy5sZW5ndGh9IGl0ZW1zYCxcclxuICAgIClcclxuICAgIGxldCBkZWxldGVkQ291bnQgPSAwXHJcbiAgICBldmFsdWF0aW9uSWRzLmZvckVhY2goKGlkKSA9PiB7XHJcbiAgICAgIGNvbnN0IGkgPSBtZW0uZmluZEluZGV4KChyKSA9PiByLmlkID09PSBpZClcclxuICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgbWVtLnNwbGljZShpLCAxKVxyXG4gICAgICAgIGRlbGV0ZWRDb3VudCsrXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICBjb25zb2xlLmxvZyhgRGVsZXRlZCAke2RlbGV0ZWRDb3VudH0gaXRlbXMgZnJvbSBpbi1tZW1vcnkuIFJlbWFpbmluZyBjb3VudDogJHttZW0ubGVuZ3RofWApXHJcbiAgICByZXR1cm4gZGVsZXRlZENvdW50ID4gMFxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGlmIChldmFsdWF0aW9uSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIk5lb246IE5vIGV2YWx1YXRpb24gSURzIHByb3ZpZGVkIGZvciBtdWx0aXBsZSBkZWxldGVcIilcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coYERlbGV0aW5nIG11bHRpcGxlIGV2YWx1YXRpb25zOiAke2V2YWx1YXRpb25JZHMubGVuZ3RofSBpdGVtc2ApXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWwhYERFTEVURSBGUk9NIGFocF9ldmFsdWF0aW9ucyBXSEVSRSBpZCA9IEFOWSgke2V2YWx1YXRpb25JZHN9KSBSRVRVUk5JTkcgaWRgXHJcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSByZXN1bHQubGVuZ3RoXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlZCAke2RlbGV0ZWRDb3VudH0gb3V0IG9mICR7ZXZhbHVhdGlvbklkcy5sZW5ndGh9IGV2YWx1YXRpb25zYClcclxuICAgIHJldHVybiBkZWxldGVkQ291bnQgPiAwXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYE5lb246IEVycm9yIGRlbGV0aW5nIG11bHRpcGxlIGV2YWx1YXRpb25zOmAsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgZXZhbHVhdGlvbklkcyxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogREVMRVRFIGFsbCAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsQUhQRXZhbHVhdGlvbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBOZW9uIERCIG5vdCByZWFkeSAoJHtjb25uZWN0aW9uRXJyb3J9KSwgZGVsZXRpbmcgYWxsIGZyb20gaW4tbWVtb3J5YClcclxuICAgIGNvbnN0IHByZXZpb3VzQ291bnQgPSBtZW0ubGVuZ3RoXHJcbiAgICBtZW0ubGVuZ3RoID0gMFxyXG4gICAgY29uc29sZS5sb2coYERlbGV0ZWQgYWxsICR7cHJldmlvdXNDb3VudH0gaXRlbXMgZnJvbSBpbi1tZW1vcnlgKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc29sZS5sb2coXCJEZWxldGluZyBhbGwgZXZhbHVhdGlvbnMgZnJvbSBOZW9uLi4uXCIpXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWwhYERFTEVURSBGUk9NIGFocF9ldmFsdWF0aW9ucyBSRVRVUk5JTkcgaWRgXHJcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSByZXN1bHQubGVuZ3RoXHJcbiAgICBjb25zb2xlLmxvZyhgTmVvbjogRGVsZXRlZCBhbGwgJHtkZWxldGVkQ291bnR9IGV2YWx1YXRpb25zYClcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJOZW9uOiBFcnJvciBkZWxldGluZyBhbGwgZXZhbHVhdGlvbnM6XCIsIGVycm9yKVxyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgfSlcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogQ2FsY3VsYXRlIGF2ZXJhZ2Ugd2VpZ2h0cyAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZVdlaWdodHMoZXZhbHVhdGlvbnM6IEFIUEV2YWx1YXRpb25bXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xyXG4gIGlmIChldmFsdWF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiB7fVxyXG5cclxuICBjb25zdCBhbGxXZWlnaHRzID0gZXZhbHVhdGlvbnMubWFwKChldmFsdWF0aW9uKSA9PiBldmFsdWF0aW9uLmdsb2JhbF93ZWlnaHRzKVxyXG4gIGNvbnN0IGNyaXRlcmlhSWRzID0gT2JqZWN0LmtleXMoYWxsV2VpZ2h0c1swXSB8fCB7fSlcclxuICBjb25zdCBhdmVyYWdlV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XHJcblxyXG4gIGNyaXRlcmlhSWRzLmZvckVhY2goKGNyaXRlcmlhSWQpID0+IHtcclxuICAgIGNvbnN0IHdlaWdodHMgPSBhbGxXZWlnaHRzLm1hcCgodykgPT4gd1tjcml0ZXJpYUlkXSB8fCAwKVxyXG4gICAgYXZlcmFnZVdlaWdodHNbY3JpdGVyaWFJZF0gPSB3ZWlnaHRzLnJlZHVjZSgoc3VtLCB3ZWlnaHQpID0+IHN1bSArIHdlaWdodCwgMCkgLyB3ZWlnaHRzLmxlbmd0aFxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBhdmVyYWdlV2VpZ2h0c1xyXG59XHJcblxyXG4vKiBTdG9yYWdlIHN0YXRzICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHMoKSB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsRXZhbHVhdGlvbnM6IG1lbS5sZW5ndGgsXHJcbiAgICAgIGxhc3RVcGRhdGVkOlxyXG4gICAgICAgIG1lbS5sZW5ndGggPiAwXHJcbiAgICAgICAgICA/IG1lbS5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLnVwZGF0ZWRfYXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEudXBkYXRlZF9hdCkuZ2V0VGltZSgpKVswXS51cGRhdGVkX2F0XHJcbiAgICAgICAgICA6IG51bGwsXHJcbiAgICAgIHN0b3JhZ2U6IFwiaW4tbWVtb3J5XCIsXHJcbiAgICAgIGNvbm5lY3Rpb25FcnJvcixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBpbml0UHJvbWlzZVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsIWBcclxuICAgICAgU0VMRUNUIFxyXG4gICAgICAgIENPVU5UKCopIGFzIHRvdGFsX2V2YWx1YXRpb25zLFxyXG4gICAgICAgIE1BWCh1cGRhdGVkX2F0KSBhcyBsYXN0X3VwZGF0ZWRcclxuICAgICAgRlJPTSBhaHBfZXZhbHVhdGlvbnNcclxuICAgIGBcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEV2YWx1YXRpb25zOiBOdW1iZXIocmVzdWx0WzBdLnRvdGFsX2V2YWx1YXRpb25zKSxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IHJlc3VsdFswXS5sYXN0X3VwZGF0ZWQsXHJcbiAgICAgIHN0b3JhZ2U6IFwibmVvblwiLFxyXG4gICAgICBjb25uZWN0aW9uRXJyb3I6IG51bGwsXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCLEsHN0YXRpc3RpayBhbG1hIGhhdGFzxLE6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxFdmFsdWF0aW9uczogMCxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IG51bGwsXHJcbiAgICAgIHN0b3JhZ2U6IFwiZXJyb3JcIixcclxuICAgICAgY29ubmVjdGlvbkVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogRGF0YWJhc2UgY29ubmVjdGlvbiBjaGVjayAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEYXRhYmFzZUNvbm5lY3Rpb24oKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFuZW9uUmVhZHkpIHtcclxuICAgIGNvbnNvbGUubG9nKGBEYXRhYmFzZSBjb25uZWN0aW9uIGNoZWNrIGZhaWxlZDogJHtjb25uZWN0aW9uRXJyb3J9YClcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRQcm9taXNlXHJcbiAgICAvLyBUZXN0IHRoZSBjb25uZWN0aW9uIHdpdGggYSBzaW1wbGUgcXVlcnlcclxuICAgIGF3YWl0IHNxbCFgU0VMRUNUIDEgYXMgdGVzdGBcclxuICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2UgY29ubmVjdGlvbiB0ZXN0IHN1Y2Nlc3NmdWxcIilcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuLyogU2ltcGxlIGNvbm5lY3Rpb24gc3RhdHVzIGNoZWNrICh3aXRob3V0IGFjdHVhbCBxdWVyeSkgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YWJhc2VSZWFkeSgpOiBib29sZWFuIHtcclxuICByZXR1cm4gbmVvblJlYWR5ICYmIHNxbCAhPT0gbnVsbFxyXG59XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuLyogIFV0aWxpdHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5mdW5jdGlvbiBwYXJzZVJvdyhyb3c6IGFueSk6IEFIUEV2YWx1YXRpb24ge1xyXG4gIGNvbnN0IHNhZmVKc29uUGFyc2UgPSAodmFsdWU6IGFueSwgZmFsbGJhY2s6IGFueSA9IHt9KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZSAvLyBBbHJlYWR5IHBhcnNlZFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSlNPTiBwYXJzZSBlcnJvciBmb3IgdmFsdWU6XCIsIHZhbHVlLCBlcnJvcilcclxuICAgICAgICByZXR1cm4gZmFsbGJhY2tcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiByb3cuaWQsXHJcbiAgICB1c2VyX25hbWU6IHJvdy51c2VyX25hbWUsXHJcbiAgICBjcml0ZXJpYV93ZWlnaHRzOiBzYWZlSnNvblBhcnNlKHJvdy5jcml0ZXJpYV93ZWlnaHRzLCB7fSksXHJcbiAgICBnbG9iYWxfd2VpZ2h0czogc2FmZUpzb25QYXJzZShyb3cuZ2xvYmFsX3dlaWdodHMsIHt9KSxcclxuICAgIGNvbnNpc3RlbmN5X3Jlc3VsdHM6IHNhZmVKc29uUGFyc2Uocm93LmNvbnNpc3RlbmN5X3Jlc3VsdHMsIHt9KSxcclxuICAgIGhpZXJhcmNoeV9kYXRhOiBzYWZlSnNvblBhcnNlKHJvdy5oaWVyYXJjaHlfZGF0YSwge30pLFxyXG4gICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXHJcbiAgICB1cGRhdGVkX2F0OiByb3cudXBkYXRlZF9hdCxcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcclxuICByZXR1cm4gRGF0ZS5ub3coKS50b1N0cmluZygzNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKVxyXG59XHJcblxyXG4vLyBFeHBvcnQgY29ubmVjdGlvbiBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cygpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbmVvblJlYWR5LFxyXG4gICAgY29ubmVjdGlvbkVycm9yLFxyXG4gICAgaGFzRW52aXJvbm1lbnRVcmw6ICEhcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMLFxyXG4gICAgdXJsVmFsaWQ6IHByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTCA/IHZhbGlkYXRlRGF0YWJhc2VVcmwocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSA6IGZhbHNlLFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsibmVvbiIsInNxbCIsIm5lb25SZWFkeSIsImNvbm5lY3Rpb25FcnJvciIsInZhbGlkYXRlRGF0YWJhc2VVcmwiLCJ1cmwiLCJzdGFydHNXaXRoIiwidXJsT2JqIiwiVVJMIiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInByb2Nlc3MiLCJlbnYiLCJEQVRBQkFTRV9VUkwiLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJlIiwiZXJyb3IiLCJtZXNzYWdlIiwiY3JlYXRlVGFibGVzIiwiaW5pdFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1lbSIsIm1lbUZpbmRCeVVzZXIiLCJ1IiwiZmluZCIsInVzZXJfbmFtZSIsIm1lbVNhdmUiLCJyb3ciLCJpIiwiZmluZEluZGV4IiwicHVzaCIsImluaXRpYWxpemVEYXRhYmFzZSIsInNhdmVBSFBFdmFsdWF0aW9uIiwidXNlck5hbWUiLCJjcml0ZXJpYVdlaWdodHMiLCJnbG9iYWxXZWlnaHRzIiwiY29uc2lzdGVuY3lSZXN1bHRzIiwiaGllcmFyY2h5RGF0YSIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIndhcm4iLCJpZCIsImdlbmVyYXRlSWQiLCJjcml0ZXJpYV93ZWlnaHRzIiwiZ2xvYmFsX3dlaWdodHMiLCJjb25zaXN0ZW5jeV9yZXN1bHRzIiwiaGllcmFyY2h5X2RhdGEiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImV4aXN0aW5nIiwibGVuZ3RoIiwicmVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlUm93Iiwic3RhY2siLCJnZXRBbGxBSFBFdmFsdWF0aW9ucyIsIm1hcCIsImdldEFIUEV2YWx1YXRpb25CeVVzZXIiLCJkZWxldGVBSFBFdmFsdWF0aW9uIiwic3BsaWNlIiwicmVzdWx0IiwiZGVsZXRlZCIsImRlbGV0ZU11bHRpcGxlQUhQRXZhbHVhdGlvbnMiLCJldmFsdWF0aW9uSWRzIiwiZGVsZXRlZENvdW50IiwiZm9yRWFjaCIsInIiLCJkZWxldGVBbGxBSFBFdmFsdWF0aW9ucyIsInByZXZpb3VzQ291bnQiLCJjYWxjdWxhdGVBdmVyYWdlV2VpZ2h0cyIsImV2YWx1YXRpb25zIiwiYWxsV2VpZ2h0cyIsImV2YWx1YXRpb24iLCJjcml0ZXJpYUlkcyIsIk9iamVjdCIsImtleXMiLCJhdmVyYWdlV2VpZ2h0cyIsImNyaXRlcmlhSWQiLCJ3ZWlnaHRzIiwidyIsInJlZHVjZSIsInN1bSIsIndlaWdodCIsImdldFN0b3JhZ2VTdGF0cyIsInRvdGFsRXZhbHVhdGlvbnMiLCJsYXN0VXBkYXRlZCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJzdG9yYWdlIiwiTnVtYmVyIiwidG90YWxfZXZhbHVhdGlvbnMiLCJsYXN0X3VwZGF0ZWQiLCJjaGVja0RhdGFiYXNlQ29ubmVjdGlvbiIsImlzRGF0YWJhc2VSZWFkeSIsInNhZmVKc29uUGFyc2UiLCJ2YWx1ZSIsImZhbGxiYWNrIiwicGFyc2UiLCJ0b1N0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJoYXNFbnZpcm9ubWVudFVybCIsInVybFZhbGlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/neon-db.ts\n"));

/***/ })

});